{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Waldiez!","text":""},{"location":"#waldiez","title":"Waldiez","text":"<p>To a python script or a jupyter notebook with the corresponding pyautogen agents and chats.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Export .waldiez flows to .py or .ipynb</li> <li>Run a .waldiez flow</li> <li>Include a <code>logs</code> folder with the logs of the flow in csv format</li> <li>Provide a custom IOSStream to handle input and output.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>From this repository:</p> <pre><code>python -m pip install https://github.com/waldiez/py.git\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code># Export a Waldiez flow to a python script or a jupyter notebook\nwaldiez --export /path/to/a/flow.waldiez --output /path/to/an/output[.py|.ipynb]\n# Export and run the script, optionally force generation if the output file already exists\nwaldiez /path/to/a/flow.waldiez --output /path/to/an/output[.py] [--force]\n</code></pre>"},{"location":"#tools","title":"Tools","text":"<ul> <li>pyautogen</li> <li>juptytext</li> <li>twisted</li> <li>pydantic</li> </ul>"},{"location":"exporter/","title":"WaldieExporter","text":"<p>Waldie exporter.</p> <p>The role of the exporter is to export the model's data to an autogen's flow with one or more chats.</p> <p>The resulting file(s): a <code>flow.py</code> file with one <code>main()</code> function to trigger the chat(s). If additional tools/skills are used, they are exported as their <code>skill_name</code> in the same directory with the <code>flow.py</code> file. So the <code>flow.py</code> could have entries like: <code>form {skill1_name} import {skill1_name}</code> <code>form {skill2_name} import {skill2_name}</code></p>"},{"location":"exporter/#waldiez.exporter.WaldieExporter","title":"<code>WaldieExporter(waldie: Waldie)</code>","text":"<p>Waldie exporter.</p> <p>Attributes:     waldie (Waldie): The Waldie instance.</p> <p>Initialize the Waldie exporter.</p> <p>Parameters:     waldie (Waldie): The Waldie instance.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def __init__(self, waldie: Waldie) -&gt; None:\n    \"\"\"Initialize the Waldie exporter.\n\n    Parameters:\n        waldie (Waldie): The Waldie instance.\n    \"\"\"\n    self.waldie = waldie\n    self._initialize()\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldieExporter.export","title":"<code>export(path: Union[str, Path], force: bool = False) -&gt; None</code>","text":"<p>Export the Waldie instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to export to.</p> required <code>force</code> <code>bool</code> <p>Override the output file if it already exists, by default False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file already exists and force is False.</p> <code>IsADirectoryError</code> <p>If the output is a directory.</p> <code>ValueError</code> <p>If the file extension is invalid.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def export(self, path: Union[str, Path], force: bool = False) -&gt; None:\n    \"\"\"Export the Waldie instance.\n\n    Parameters\n    ----------\n    path : Union[str, Path]\n        The path to export to.\n    force : bool, optional\n        Override the output file if it already exists, by default False.\n\n    Raises\n    ------\n    FileExistsError\n        If the file already exists and force is False.\n    IsADirectoryError\n        If the output is a directory.\n    ValueError\n        If the file extension is invalid.\n    \"\"\"\n    if not isinstance(path, Path):\n        path = Path(path)\n    path = path.resolve()\n    if path.is_dir():\n        raise IsADirectoryError(f\"Output is a directory: {path}\")\n    if path.exists():\n        if force is False:\n            raise FileExistsError(f\"File already exists: {path}\")\n        path.unlink()\n    if not path.parent.exists():\n        path.parent.mkdir(parents=True, exist_ok=True)\n    extension = path.suffix\n    if extension == \".waldiez\":\n        self.to_waldie(path)\n    elif extension == \".py\":\n        self.to_py(path)\n    elif extension == \".ipynb\":\n        self.to_ipynb(path)\n    else:\n        raise ValueError(f\"Invalid extension: {extension}\")\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldieExporter.load","title":"<code>load(file_path: Path) -&gt; WaldieExporter</code>  <code>classmethod</code>","text":"<p>Load the Waldie instance from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The file path.</p> required <p>Returns:</p> Type Description <code>WaldieExporter</code> <p>The Waldie exporter.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>@classmethod\ndef load(cls, file_path: Path) -&gt; \"WaldieExporter\":\n    \"\"\"Load the Waldie instance from a file.\n\n    Parameters\n    ----------\n    file_path : Path\n        The file path.\n\n    Returns\n    -------\n    WaldieExporter\n        The Waldie exporter.\n    \"\"\"\n    waldie = Waldie.load(file_path)\n    return cls(waldie)\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldieExporter.to_ipynb","title":"<code>to_ipynb(path: Path) -&gt; None</code>","text":"<p>Export flow to jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to export to.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the notebook could not be generated.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def to_ipynb(self, path: Path) -&gt; None:\n    \"\"\"Export flow to jupyter notebook.\n\n    Parameters\n    ----------\n    path : Path\n        The path to export to.\n\n    Raises\n    ------\n    RuntimeError\n        If the notebook could not be generated.\n    \"\"\"\n    include_retrieve_chat = self.waldie.has_rag_agents\n    pip_install_autogen = (\n        \"# !{sys.executable} -m pip install -q 'pyautogen[retrievechat]'\\n\"\n        if include_retrieve_chat\n        else \"# !{sys.executable} -m pip install -q pyautogen\\n\"\n    )\n    content = f\"{comment(True)}{self.waldie.name}\" + \"\\n\\n\"\n    content += f\"{comment(True, 2)}Dependencies\" + \"\\n\\n\"\n    content += \"import sys\\n\"\n    content += pip_install_autogen\n    extra_requirements = \" \".join(self.waldie.requirements)\n    if extra_requirements:\n        content += (\n            f\"# !{{sys.executable}} -m pip install -q {extra_requirements}\"\n            + \"\\n\"\n        )\n    content += export_flow(\n        waldie=self.waldie,\n        agents=(self._agents, self._agent_names),\n        chats=(self._chats, self._chat_names),\n        models=(self._models, self._model_names),\n        skills=(self._skills, self._skill_names),\n        output_dir=path.parent,\n        notebook=True,\n    )\n    # we first create a .py file with the content\n    # and then convert it to a notebook using jupytext\n    py_path = path.with_suffix(\".tmp.py\")\n    with open(py_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(content)\n    if not shutil.which(\"jupytext\"):\n        run_command(\n            [sys.executable, \"-m\", \"pip\", \"install\", \"jupytext\"],\n            allow_error=False,\n            silent=True,\n        )\n    run_command(\n        [\"jupytext\", \"--to\", \"notebook\", str(py_path)],\n        silent=True,\n        allow_error=False,\n    )\n    ipynb_path = str(py_path).replace(\".tmp.py\", \".tmp.ipynb\")\n    if not os.path.exists(ipynb_path):\n        raise RuntimeError(\"Could not generate notebook\")\n    Path(ipynb_path).rename(ipynb_path.replace(\".tmp.ipynb\", \".ipynb\"))\n    py_path.unlink()\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldieExporter.to_py","title":"<code>to_py(path: Path) -&gt; None</code>","text":"<p>Export waldie flow to python script.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to export to.</p> required Source code in <code>waldiez/exporter.py</code> <pre><code>def to_py(self, path: Path) -&gt; None:\n    \"\"\"Export waldie flow to python script.\n\n    Parameters\n    ----------\n    path : Path\n        The path to export to.\n    \"\"\"\n    content = \"#!/usr/bin/env python\\n\"\n    content += f'\"\"\"{self.waldie.name}\\n\\n'\n    content += f\"{self.waldie.description}\\n\\n\"\n    content += f\"Tags: {', '.join(self.waldie.tags)}\\n\\n\"\n    content += f\"Requirements: {', '.join(self.waldie.requirements)}\\n\\n\"\n    content += '\"\"\"\\n\\n'\n    content += \"# cspell: disable\\n\\n\"\n    content += export_flow(\n        waldie=self.waldie,\n        agents=(self._agents, self._agent_names),\n        chats=(self._chats, self._chat_names),\n        models=(self._models, self._model_names),\n        skills=(self._skills, self._skill_names),\n        output_dir=path.parent,\n        notebook=False,\n    )\n    content += '\\n\\nif __name__ == \"__main__\":\\n'\n    content += \"    print(main())\\n\"\n    with open(path, \"w\", encoding=\"utf-8\") as file:\n        file.write(content)\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldieExporter.to_waldie","title":"<code>to_waldie(file_path: Path) -&gt; None</code>","text":"<p>Export the Waldie instance.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The file path.</p> required Source code in <code>waldiez/exporter.py</code> <pre><code>def to_waldie(self, file_path: Path) -&gt; None:\n    \"\"\"Export the Waldie instance.\n\n    Parameters\n    ----------\n    file_path : Path\n        The file path.\n    \"\"\"\n    with open(file_path, \"w\", encoding=\"utf-8\") as file:\n        file.write(self.waldie.model_dump_json())\n</code></pre>"},{"location":"exporter/#waldiez.exporter.run_command","title":"<code>run_command(cmd: List[str], cwd: Path | None = None, allow_error: bool = True, silent: bool = False) -&gt; None</code>","text":"<p>Run a command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>List[str]</code> <p>The command to run.</p> required <code>cwd</code> <code>Path</code> <p>The working directory, by default None (current working directory).</p> <code>None</code> <code>allow_error</code> <code>bool</code> <p>Whether to allow errors, by default True.</p> <code>True</code> <code>silent</code> <code>bool</code> <p>Whether to print the command, by default False.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the command fails and allow_error is False.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def run_command(\n    cmd: List[str],\n    cwd: Path | None = None,\n    allow_error: bool = True,\n    silent: bool = False,\n) -&gt; None:\n    \"\"\"Run a command.\n\n    Parameters\n    ----------\n    cmd : List[str]\n        The command to run.\n    cwd : Path, optional\n        The working directory, by default None (current working directory).\n    allow_error : bool, optional\n        Whether to allow errors, by default True.\n    silent : bool, optional\n        Whether to print the command, by default False.\n\n    Raises\n    ------\n    RuntimeError\n        If the command fails and allow_error is False.\n    \"\"\"\n    if not cwd:\n        cwd = Path.cwd()\n    if silent is False:\n        # pylint: disable=inconsistent-quotes\n        print(f\"Running command: \\n{' '.join(cmd)}\\n\")\n    try:\n        subprocess.run(\n            cmd,\n            check=True,\n            cwd=cwd,\n            env=os.environ,\n            stdout=sys.stdout if silent is False else subprocess.DEVNULL,\n            stderr=sys.stderr if allow_error is False else subprocess.DEVNULL,\n        )  # nosemgrep # nosec\n    except BaseException as error:  # pylint: disable=broad-except\n        if allow_error:\n            return\n        raise RuntimeError(f\"Error running command: {error}\") from error\n</code></pre>"},{"location":"io_stream/","title":"WaldieIOSstream","text":"<p>Custom IOStream class to use with autogen.</p> <p>It is meant to be used when we want to use custom <code>print</code> and <code>input</code>. For example, when a websocket is used to trigger a UI element that requires user input. and sends back the user's input to the websocket. In the same way, we can use it to forward what is meant to be printed.</p> <p>We use:</p> <ul> <li>one tcp server to handle messaging between the clients</li> <li>one tcp client (provider) to set and forward the user's input   that we got elsewhere (e.g. from a websocket connection)</li> <li>one tcp client (consumer) to ask and get the input from the provider</li> </ul>"},{"location":"io_stream/#waldiez.io_stream.WaldieIOStream","title":"<code>WaldieIOStream(port: int = 0, input_timeout: float = 60, print_function: Optional[Callable[..., None]] = None, on_prompt_input: Optional[Callable[[str], None]] = None)</code>","text":"<p>               Bases: <code>IOStream</code></p> <p>Custom IOStream class to handle the <code>print</code> and <code>input</code> functions.</p> <p>Initialize the IOStream.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to use, by default 0 (auto-assign).</p> <code>0</code> <code>input_timeout</code> <code>float</code> <p>The input timeout, by default 60.</p> <code>60</code> <code>print_function</code> <code>Optional[Callable[..., None]]</code> <p>The print function to use, by default None.</p> <code>None</code> <code>on_prompt_input</code> <code>Optional[Callable[[str], None]]</code> <p>The function to call for getting an input, by default None.</p> <code>None</code> Source code in <code>waldiez/io_stream.py</code> <pre><code>def __init__(\n    self,\n    port: int = 0,\n    input_timeout: float = 60,\n    print_function: Optional[Callable[..., None]] = None,\n    on_prompt_input: Optional[Callable[[str], None]] = None,\n) -&gt; None:\n    \"\"\"Initialize the IOStream.\n\n    Parameters\n    ----------\n    port : int, optional\n        The port to use, by default 0 (auto-assign).\n    input_timeout : float, optional\n        The input timeout, by default 60.\n    print_function : Optional[Callable[..., None]], optional\n        The print function to use, by default None.\n    on_prompt_input : Optional[Callable[[str], None]], optional\n        The function to call for getting an input, by default None.\n    \"\"\"\n    self._print_function = print_function\n    if port == 0:\n        port = get_available_port()\n    self._port = port\n    self._input_timeout = input_timeout\n    self._server = TCPServer(port)\n    self._server.start()\n    self._provider = TCPProvider(\"localhost\", port, response=None)\n    self._on_prompt_input = on_prompt_input\n</code></pre>"},{"location":"io_stream/#waldiez.io_stream.WaldieIOStream.forward_input","title":"<code>forward_input(input_data: str) -&gt; None</code>","text":"<p>Forward the user's input to the provider.</p> <p>When we have the input data   e.g. from 'input(..)' or from a websocket connection,   we can forward it to the provider (the tcp client)   to make it available to the consumer (the other tcp client).</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>str</code> <p>The input data to forward.</p> required Source code in <code>waldiez/io_stream.py</code> <pre><code>def forward_input(self, input_data: str) -&gt; None:\n    \"\"\"Forward the user's input to the provider.\n\n    When we have the input data\n      e.g. from 'input(..)' or from a websocket connection,\n      we can forward it to the provider (the tcp client)\n      to make it available to the consumer (the other tcp client).\n    Parameters\n    ----------\n    input_data : str\n        The input data to forward.\n    \"\"\"\n    if not self._provider.is_running():\n        self._provider.start()\n    self._provider.set_response(input_data)\n</code></pre>"},{"location":"io_stream/#waldiez.io_stream.WaldieIOStream.input","title":"<code>input(prompt: str = '', *, password: bool = False) -&gt; str</code>","text":"<p>Mock the input function.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to show, by default \"\".</p> <code>''</code> <code>password</code> <code>(bool, optional(not used))</code> <p>Whether to show the input as password, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The user's input.</p> Source code in <code>waldiez/io_stream.py</code> <pre><code>def input(self, prompt: str = \"\", *, password: bool = False) -&gt; str:\n    \"\"\"Mock the input function.\n\n    Parameters\n    ----------\n    prompt : str, optional\n        The prompt to show, by default \"\".\n    password : bool, optional (not used)\n        Whether to show the input as password, by default False.\n\n    Returns\n    -------\n    str\n        The user's input.\n    \"\"\"\n    _prompt = prompt or \"Your input:\"\n    if _prompt in (\"&gt;\", \"&gt; \"):\n        _prompt = \"Your input:\"\n    if prompt:\n        if self._on_prompt_input:\n            self._on_prompt_input(_prompt)\n        self.print(_prompt, end=\"\")\n    if not self._provider.is_running():\n        self._provider.start()\n    # wait for the provider to start\n    self._provider.wait(timeout=self._input_timeout)\n    if not self._provider.is_running():  # pragma: no cover\n        self.print(\n            \"WARNING: Provider is not running. Was an input expected?\"\n        )\n        return \"\\n\"\n    consumer = TCPConsumer(\n        \"localhost\", self._port, timeout=self._input_timeout\n    )\n    consumer.start()\n    # send the prompt and wait for the response\n    consumer.send_prompt(_prompt)\n    response = consumer.get_response()\n    consumer.stop()\n    self._provider.stop()\n    # return the response or a line break (i.e. no input)\n    return response or \"\\n\"\n</code></pre>"},{"location":"io_stream/#waldiez.io_stream.WaldieIOStream.print","title":"<code>print(*objects: Any, sep: str = ' ', end: str = '\\n', flush: bool = False) -&gt; None</code>","text":"<p>Mock the print function.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>Any</code> <p>The objects to print.</p> <code>()</code> <code>sep</code> <code>str</code> <p>The separator, by default \" \".</p> <code>' '</code> <code>end</code> <code>str</code> <p>The end, by default a new line.</p> <code>'\\n'</code> <code>flush</code> <code>bool</code> <p>Whether to flush, by default False.</p> <code>False</code> Source code in <code>waldiez/io_stream.py</code> <pre><code>def print(\n    self,\n    *objects: Any,\n    sep: str = \" \",\n    end: str = \"\\n\",\n    flush: bool = False,\n) -&gt; None:\n    \"\"\"Mock the print function.\n\n    Parameters\n    ----------\n    objects : Any\n        The objects to print.\n    sep : str, optional\n        The separator, by default \" \".\n    end : str, optional\n        The end, by default a new line.\n    flush : bool, optional\n        Whether to flush, by default False.\n    \"\"\"\n    print_function: Callable[..., None] = self.print_function or print\n    print_function(*objects, sep=sep, end=end, flush=flush)\n</code></pre>"},{"location":"io_stream/#waldiez.io_stream.WaldieIOStream.print_function","title":"<code>print_function: Optional[Callable[..., None]]</code>  <code>property</code>","text":"<p>Get the print function.</p>"},{"location":"io_stream/#waldiez.io_stream.get_available_port","title":"<code>get_available_port() -&gt; int</code>","text":"<p>Get an available port.</p> <p>Returns:</p> Type Description <code>int</code> <p>Available port.</p> Source code in <code>waldiez/io_stream.py</code> <pre><code>def get_available_port() -&gt; int:\n    \"\"\"Get an available port.\n\n    Returns\n    -------\n    int\n        Available port.\n    \"\"\"\n    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as soc:\n        soc.bind((\"\", 0))\n        soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        return soc.getsockname()[1]\n</code></pre>"},{"location":"runner/","title":"WaldieRunner","text":"<p>Waldie Flow runner.</p> <p>Run a waldie flow. The flow is first converted to an autogen flow with agents, chats and skills. We then chown to temporary directory, call the flow's <code>main()</code> and return the results. Before running the flow, any additional environment variables specified in the waldie file are set.</p>"},{"location":"runner/#waldiez.runner.WaldieRunner","title":"<code>WaldieRunner(waldie: Waldie, file_path: Optional[Union[str, Path]] = None)</code>","text":"<p>Waldie runner class.</p> <p>Initialize the Waldie manager.</p> Source code in <code>waldiez/runner.py</code> <pre><code>def __init__(\n    self, waldie: Waldie, file_path: Optional[Union[str, Path]] = None\n) -&gt; None:\n    \"\"\"Initialize the Waldie manager.\"\"\"\n    self._waldie = waldie\n    self._running = False\n    self._file_path = file_path\n    self._stream: ContextVar[Optional[WaldieIOStream]] = ContextVar(\n        \"waldie_stream\", default=None\n    )\n    self._exporter = WaldieExporter(waldie)\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldieRunner.load","title":"<code>load(waldie_file: Union[str, Path], name: Optional[str] = None, description: Optional[str] = None, tags: Optional[List[str]] = None, requirements: Optional[List[str]] = None) -&gt; WaldieRunner</code>  <code>classmethod</code>","text":"<p>Create a WaldieRunner instance from a file.</p> <p>Parameters:</p> Name Type Description Default <code>waldie_file</code> <code>Union[str, Path]</code> <p>The file path.</p> required <code>name</code> <code>Optional[str]</code> <p>The name of the Waldie, by default None.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description of the Waldie, by default None.</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>The tags of the Waldie, by default None.</p> <code>None</code> <code>requirements</code> <code>Optional[List[str]]</code> <p>The requirements of the Waldie, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>WaldieRunner</code> <p>The Waldie runner instance.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file is not found.</p> <code>RuntimeError</code> <p>If the file is not a valid Waldie file.</p> Source code in <code>waldiez/runner.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    waldie_file: Union[str, Path],\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    requirements: Optional[List[str]] = None,\n) -&gt; \"WaldieRunner\":\n    \"\"\"Create a WaldieRunner instance from a file.\n\n    Parameters\n    ----------\n    waldie_file : Union[str, Path]\n        The file path.\n    name : Optional[str], optional\n        The name of the Waldie, by default None.\n    description : Optional[str], optional\n        The description of the Waldie, by default None.\n    tags : Optional[List[str]], optional\n        The tags of the Waldie, by default None.\n    requirements : Optional[List[str]], optional\n        The requirements of the Waldie, by default None.\n\n    Returns\n    -------\n    WaldieRunner\n        The Waldie runner instance.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the file is not found.\n    RuntimeError\n        If the file is not a valid Waldie file.\n    \"\"\"\n    waldie = Waldie.load(\n        waldie_file,\n        name=name,\n        description=description,\n        tags=tags,\n        requirements=requirements,\n    )\n    return cls(waldie, file_path=waldie_file)\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldieRunner.run","title":"<code>run(stream: Optional[WaldieIOStream] = None, output_path: Optional[Union[str, Path]] = None) -&gt; Union[ChatResult, List[ChatResult]]</code>","text":"<p>Run the Waldie workflow.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>Optional[WaldieIOStream]</code> <p>The stream to use, by default None.</p> <code>None</code> <code>output_path</code> <code>Optional[Union[str, Path]]</code> <p>The output path, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[ChatResult, List[ChatResult]]</code> <p>The result of the chat(s).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the workflow is already running.</p> Source code in <code>waldiez/runner.py</code> <pre><code>def run(\n    self,\n    stream: Optional[WaldieIOStream] = None,\n    output_path: Optional[Union[str, Path]] = None,\n) -&gt; Union[ChatResult, List[ChatResult]]:\n    \"\"\"Run the Waldie workflow.\n\n    Parameters\n    ----------\n    stream : Optional[WaldieIOStream], optional\n        The stream to use, by default None.\n    output_path : Optional[Union[str, Path]], optional\n        The output path, by default None.\n\n    Returns\n    -------\n    Union[ChatResult, List[ChatResult]]\n        The result of the chat(s).\n\n    Raises\n    ------\n    RuntimeError\n        If the workflow is already running.\n    \"\"\"\n    if self._running is True:\n        raise RuntimeError(\"Workflow already running\")\n    self._running = True\n    token = self._stream.set(stream)\n    file_path = output_path or self._file_path\n    try:\n        return self._run(file_path)\n    finally:\n        self._running = False\n        self._stream.reset(token)\n        del token\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldieRunner.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Get the running status.</p>"},{"location":"runner/#waldiez.runner.WaldieRunner.waldie","title":"<code>waldie: Waldie</code>  <code>property</code>","text":"<p>Get the Waldie.</p>"},{"location":"waldie/","title":"Waldie","text":"<p>Waldie data class.</p> <p>A Waldie class contains all the information that is needed to generate and run an autogen workflow. It has the model/LLM configurations, the agent definitions and their optional additional skills to be used.</p>"},{"location":"waldie/#waldiez.waldie.Waldie","title":"<code>Waldie(flow: WaldieFlow)</code>  <code>dataclass</code>","text":"<p>Waldie data class.</p> <p>It contains all the information to generate and run an autogen workflow.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.agents","title":"<code>agents: Iterator[WaldieAgent]</code>  <code>property</code>","text":"<p>Get the agents.</p> <p>Yields:</p> Type Description <code>WaldieAgent</code> <p>The flow agents.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.chats","title":"<code>chats: List[Tuple[WaldieChat, WaldieAgent, WaldieAgent]]</code>  <code>property</code>","text":"<p>Get the chats.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Get the flow description.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.from_dict","title":"<code>from_dict(data: Dict[str, Any], flow_id: Optional[str] = None, name: Optional[str] = None, description: Optional[str] = None, tags: Optional[List[str]] = None, requirements: Optional[List[str]] = None) -&gt; Waldie</code>  <code>classmethod</code>","text":"<p>Create a Waldie from dict.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data.</p> required <code>flow_id</code> <code>Optional[str]</code> <p>The flow id, by default None (retrieved from data or generated).</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>The name, by default None (retrieved from data).</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description, by default None (retrieved from data).</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>The tags, by default None (retrieved from data).</p> <code>None</code> <code>requirements</code> <code>Optional[List[str]]</code> <p>The requirements, by default None (retrieved from data).</p> <code>None</code> <p>Returns:</p> Type Description <code>Waldie</code> <p>The Waldie.</p> Source code in <code>waldiez/waldie.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    data: Dict[str, Any],\n    flow_id: Optional[str] = None,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    requirements: Optional[List[str]] = None,\n) -&gt; \"Waldie\":\n    \"\"\"Create a Waldie from dict.\n\n    Parameters\n    ----------\n    data : Dict[str, Any]\n        The data.\n    flow_id : Optional[str], optional\n        The flow id, by default None (retrieved from data or generated).\n    name : Optional[str], optional\n        The name, by default None (retrieved from data).\n    description : Optional[str], optional\n        The description, by default None (retrieved from data).\n    tags : Optional[List[str]], optional\n        The tags, by default None (retrieved from data).\n    requirements : Optional[List[str]], optional\n        The requirements, by default None (retrieved from data).\n\n    Returns\n    -------\n    Waldie\n        The Waldie.\n    \"\"\"\n    flow = _get_flow(\n        data,\n        flow_id=flow_id,\n        name=name,\n        description=description,\n        tags=tags,\n        requirements=requirements,\n    )\n    return cls(flow=WaldieFlow.model_validate(flow))\n</code></pre>"},{"location":"waldie/#waldiez.waldie.Waldie.get_flow_env_vars","title":"<code>get_flow_env_vars() -&gt; List[Tuple[str, str]]</code>","text":"<p>Get the flow environment variables.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>The environment variables for the flow.</p> Source code in <code>waldiez/waldie.py</code> <pre><code>def get_flow_env_vars(self) -&gt; List[Tuple[str, str]]:\n    \"\"\"Get the flow environment variables.\n\n    Returns\n    -------\n    List[Tuple[str, str]]\n        The environment variables for the flow.\n    \"\"\"\n    env_vars: List[Tuple[str, str]] = []\n    for skill in self.skills:\n        for secret_key, secret_value in skill.secrets.items():\n            env_vars.append((secret_key, secret_value))\n    return env_vars\n</code></pre>"},{"location":"waldie/#waldiez.waldie.Waldie.get_group_chat_members","title":"<code>get_group_chat_members(agent: WaldieAgent) -&gt; List[WaldieAgent]</code>","text":"<p>Get the chat members that connect to a group chat manger agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent (group chat manager).</p> required <p>Returns:</p> Type Description <code>List[WaldieAgent]</code> <p>The group chat members.</p> Source code in <code>waldiez/waldie.py</code> <pre><code>def get_group_chat_members(self, agent: WaldieAgent) -&gt; List[WaldieAgent]:\n    \"\"\"Get the chat members that connect to a group chat manger agent.\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent (group chat manager).\n\n    Returns\n    -------\n    List[WaldieAgent]\n        The group chat members.\n    \"\"\"\n    if agent.agent_type != \"manager\":\n        return []\n    return self.flow.get_group_chat_members(agent.id)\n</code></pre>"},{"location":"waldie/#waldiez.waldie.Waldie.has_rag_agents","title":"<code>has_rag_agents: bool</code>  <code>property</code>","text":"<p>Check if the flow has RAG agents.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.load","title":"<code>load(waldie_file: Union[str, Path], name: Optional[str] = None, description: Optional[str] = None, tags: Optional[List[str]] = None, requirements: Optional[List[str]] = None) -&gt; Waldie</code>  <code>classmethod</code>","text":"<p>Load a Waldie from a file.</p> <p>Parameters:</p> Name Type Description Default <code>waldie_file</code> <code>Union[str, Path]</code> <p>The Waldie file.</p> required <code>name</code> <code>Optional[str]</code> <p>The name, by default None.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description, by default None.</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>The tags, by default None.</p> <code>None</code> <code>requirements</code> <code>Optional[List[str]]</code> <p>The requirements, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Waldie</code> <p>The Waldie.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is not found or invalid JSON.</p> Source code in <code>waldiez/waldie.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    waldie_file: Union[str, Path],\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    requirements: Optional[List[str]] = None,\n) -&gt; \"Waldie\":\n    \"\"\"Load a Waldie from a file.\n\n    Parameters\n    ----------\n    waldie_file : Union[str, Path]\n        The Waldie file.\n    name : Optional[str], optional\n        The name, by default None.\n    description : Optional[str], optional\n        The description, by default None.\n    tags : Optional[List[str]], optional\n        The tags, by default None.\n    requirements : Optional[List[str]], optional\n        The requirements, by default None.\n\n    Returns\n    -------\n    Waldie\n        The Waldie.\n\n    Raises\n    ------\n    ValueError\n        If the file is not found or invalid JSON.\n    \"\"\"\n    data: Dict[str, Any] = {}\n    if not Path(waldie_file).exists():\n        raise ValueError(f\"File not found: {waldie_file}\")\n    with open(waldie_file, \"r\", encoding=\"utf-8\") as file:\n        try:\n            data = json.load(file)\n        except json.decoder.JSONDecodeError as error:\n            raise ValueError(f\"Invalid JSON: {waldie_file}\") from error\n    return cls.from_dict(\n        data,\n        name=name,\n        description=description,\n        tags=tags,\n        requirements=requirements,\n    )\n</code></pre>"},{"location":"waldie/#waldiez.waldie.Waldie.model_dump_json","title":"<code>model_dump_json(by_alias: bool = True, indent: Optional[int] = None) -&gt; str</code>","text":"<p>Get the model dump json.</p> <p>We use <code>by_alias=True</code> by default to use the alias (toCamel).</p> <p>Parameters:</p> Name Type Description Default <code>by_alias</code> <code>bool</code> <p>Use alias (toCamel), by default True.</p> <code>True</code> <code>indent</code> <code>Optional[int]</code> <p>The indent, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The model dump json.</p> Source code in <code>waldiez/waldie.py</code> <pre><code>def model_dump_json(\n    self, by_alias: bool = True, indent: Optional[int] = None\n) -&gt; str:\n    \"\"\"Get the model dump json.\n\n    We use `by_alias=True` by default to use the alias (toCamel).\n\n    Parameters\n    ----------\n    by_alias : bool, optional\n        Use alias (toCamel), by default True.\n    indent : Optional[int], optional\n        The indent, by default None.\n\n    Returns\n    -------\n    str\n        The model dump json.\n    \"\"\"\n    return self.flow.model_dump_json(by_alias=by_alias, indent=indent)\n</code></pre>"},{"location":"waldie/#waldiez.waldie.Waldie.models","title":"<code>models: Iterator[WaldieModel]</code>  <code>property</code>","text":"<p>Get the models.</p> <p>Yields:</p> Type Description <code>WaldieModel</code> <p>The flow models.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the flow name.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.requirements","title":"<code>requirements: List[str]</code>  <code>property</code>","text":"<p>Get the flow requirements.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.skills","title":"<code>skills: Iterator[WaldieSkill]</code>  <code>property</code>","text":"<p>Get the flow skills.</p> <p>Yields:</p> Type Description <code>WaldieSkill</code> <p>The skills.</p>"},{"location":"waldie/#waldiez.waldie.Waldie.tags","title":"<code>tags: List[str]</code>  <code>property</code>","text":"<p>Get the flow tags.</p>"},{"location":"exporting/agents/","title":"Agents","text":"<p>Agent strings generation..</p> <p>Agent skills related string generation functions.</p> <p>Code execution related functions for exporting agents.</p> <p>Export group manger and group chat to string.</p> <p>Get an agent's llm config argument.</p> <p>Get the <code>is_termination_message</code> check for the agent.</p>"},{"location":"exporting/agents/#waldiez.exporting.agents.agent.export_agent","title":"<code>export_agent(agent: WaldieAgent, agent_names: Dict[str, str], model_names: Dict[str, str], skill_names: Dict[str, str], all_skills: List[WaldieSkill], group_chat_members: List[WaldieAgent]) -&gt; Tuple[str, str, Set[str]]</code>","text":"<p>Export the agent to a string.</p> <p>If the agent's <code>is_termination_msg</code> is a method, the function definition and content will be included in the string. So it could be like: <pre><code>...\ndef is_termination_message_{agent_name}(message):\n    return ....\n...\nagent_name = AssistantAgent(\n    ...\n    is_termination_msg=is_termination_message_{agent_name},\n    ...\n)\n</code></pre> The same goes for any additional <code>before the agent</code> contents in the cases of a group chat manager (define the <code>GroupChat</code> first), a retrieve user proxy agent (define the retrieve/db config first), or the agent's <code>code_execution</code>: define the <code>DockerCommandLineCodeExecutor</code>/<code>LocalCommandLineCodeExecutor</code> first.</p> <p>The agent's <code>skill_registrations</code> and/or nested chats if any, should be added to the final string after all the agents are defined. definition. Example: <pre><code>    ...\n    agent_name = AssistantAgent(\n        ...\n    )\n    ...\n    register_function(\n        {skill_name},\n        caller={caller_name},\n        executor={executor_name},\n    )\n    ...\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <code>model_names</code> <code>Dict[str, str]</code> <p>A mapping of model id to model name.</p> required <code>skill_names</code> <code>Dict[str, str]</code> <p>A mapping of skill id to skill name.</p> required <code>all_skills</code> <code>List[WaldieSkill]</code> <p>All the skills in the flow.</p> required <code>group_chat_members</code> <code>List[WaldieAgent]</code> <p>The group chat members.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str, Set[str], Set[str]]</code> <p>A tuple containing: - The string representation of the agent (w additional content before), - Extra content to be added after the agents are defined. - Needed imports (autogen.x, db/RAG or code execution related) if any.</p> Source code in <code>waldiez/exporting/agents/agent.py</code> <pre><code>def export_agent(\n    agent: WaldieAgent,\n    agent_names: Dict[str, str],\n    model_names: Dict[str, str],\n    skill_names: Dict[str, str],\n    all_skills: List[WaldieSkill],\n    group_chat_members: List[WaldieAgent],\n) -&gt; Tuple[str, str, Set[str]]:\n    \"\"\"Export the agent to a string.\n\n    If the agent's `is_termination_msg` is a method,\n    the function definition and content will be included in the string.\n    So it could be like:\n    ```python\n    ...\n    def is_termination_message_{agent_name}(message):\n        return ....\n    ...\n    agent_name = AssistantAgent(\n        ...\n        is_termination_msg=is_termination_message_{agent_name},\n        ...\n    )\n    ```\n    The same goes for any additional `before the agent` contents in the cases\n    of a group chat manager (define the `GroupChat` first),\n    a retrieve user proxy agent (define the retrieve/db config first),\n    or the agent's `code_execution`: define the\n    `DockerCommandLineCodeExecutor`/`LocalCommandLineCodeExecutor` first.\n\n    The agent's `skill_registrations` and/or nested chats if any,\n    should be added to the final string after all the agents are defined.\n    definition. Example:\n    ```python\n        ...\n        agent_name = AssistantAgent(\n            ...\n        )\n        ...\n        register_function(\n            {skill_name},\n            caller={caller_name},\n            executor={executor_name},\n        )\n        ...\n    ```\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n    model_names : Dict[str, str]\n        A mapping of model id to model name.\n    skill_names : Dict[str, str]\n        A mapping of skill id to skill name.\n    all_skills : List[WaldieSkill]\n        All the skills in the flow.\n    group_chat_members : List[WaldieAgent]\n        The group chat members.\n\n    Returns\n    -------\n    Tuple[str, str, Set[str], Set[str]]\n        A tuple containing:\n        - The string representation of the agent (w additional content before),\n        - Extra content to be added after the agents are defined.\n        - Needed imports (autogen.x, db/RAG or code execution related) if any.\n    \"\"\"\n    imports: Set[str] = set()\n    agent_name = agent_names[agent.id]\n    before_agent_string = \"\"\n    after_agent_string = \"\"\n    before_manager, group_chat_arg = get_group_manager_extras(\n        agent, group_chat_members, agent_names\n    )\n    if before_manager:\n        before_agent_string += before_manager\n    before_rag, retrieve_arg, rag_imports = get_rag_user_extras(\n        agent, agent_name, model_names\n    )\n    if before_rag:\n        before_agent_string += before_rag\n    imports.update(rag_imports)\n    is_termination_message, termination_function = get_is_termination_message(\n        agent, agent_name\n    )\n    if termination_function:\n        before_agent_string += termination_function\n    executor, config_arg, coding_import = get_agent_code_execution_config(\n        agent=agent, agent_name=agent_name, skill_names=skill_names\n    )\n    if executor:\n        before_agent_string += executor\n    if coding_import:\n        imports.add(f\"from autogen.coding import {coding_import}\")\n    agent_class = get_agent_class_name(agent)\n    imports.update(get_agent_imports(agent_class))\n    if agent.data.skills:\n        imports.add(\"from autogen import register_function\")\n    default_auto_reply: str = \"None\"\n    if agent.data.agent_default_auto_reply:\n        default_auto_reply = (\n            f'\"{get_escaped_string(agent.data.agent_default_auto_reply)}\"'\n        )\n    agent_str = f\"\"\"{agent_name} = {agent_class}(\n    name=\"{agent_name}\",\n    description=\"{agent.description}\",\n    llm_config={get_agent_llm_config(agent, model_names)},\n    human_input_mode=\"{agent.data.human_input_mode}\",\n    max_consecutive_auto_reply={agent.data.max_consecutive_auto_reply},\n    default_auto_reply={default_auto_reply},\n    code_execution_config={config_arg},\n    is_termination_msg={is_termination_message},{group_chat_arg}{retrieve_arg}\n)\n\"\"\"\n    agent_skill_registrations = get_agent_skill_registrations(\n        agent, agent_names, all_skills, skill_names\n    )\n    if before_agent_string:\n        agent_str = before_agent_string + \"\\n\" + agent_str\n    if agent_skill_registrations:\n        after_agent_string = \"\\n\" + agent_skill_registrations + \"\\n\"\n    return (\n        agent_str,\n        after_agent_string,\n        imports,\n    )\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agents.agent.get_agent_class_name","title":"<code>get_agent_class_name(agent: WaldieAgent) -&gt; str</code>","text":"<p>Get the agent class name.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The agent class name.</p> Source code in <code>waldiez/exporting/agents/agent.py</code> <pre><code>def get_agent_class_name(agent: WaldieAgent) -&gt; str:\n    \"\"\"Get the agent class name.\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n\n    Returns\n    -------\n    str\n        The agent class name.\n    \"\"\"\n    if agent.agent_type == \"assistant\":\n        return \"AssistantAgent\"\n    if agent.agent_type == \"user\":\n        return \"UserProxyAgent\"\n    if agent.agent_type == \"manager\":\n        return \"GroupChatManager\"\n    if agent.agent_type == \"rag_user\":\n        return \"RetrieveUserProxyAgent\"\n    return \"ConversableAgent\"  # pragma: no cover\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agents.agent.get_agent_imports","title":"<code>get_agent_imports(agent_class: str) -&gt; Set[str]</code>","text":"<p>Get the imports needed for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent_class</code> <code>str</code> <p>The agent class name.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>The imports needed for the agent.</p> Source code in <code>waldiez/exporting/agents/agent.py</code> <pre><code>def get_agent_imports(agent_class: str) -&gt; Set[str]:\n    \"\"\"Get the imports needed for the agent.\n\n    Parameters\n    ----------\n    agent_class : str\n        The agent class name.\n\n    Returns\n    -------\n    Set[str]\n        The imports needed for the agent.\n    \"\"\"\n    imports = set()\n    if agent_class == \"AssistantAgent\":\n        imports.add(\"from autogen import AssistantAgent\")\n    elif agent_class == \"UserProxyAgent\":\n        imports.add(\"from autogen import UserProxyAgent\")\n    elif agent_class == \"GroupChatManager\":\n        imports.add(\"from autogen import GroupChatManager\")\n        imports.add(\"from autogen import GroupChat\")\n    elif agent_class == \"RetrieveUserProxyAgent\":\n        imports.add(\n            \"from autogen.agentchat.contrib.retrieve_user_proxy_agent \"\n            \"import RetrieveUserProxyAgent\"\n        )\n    return imports\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agents.agent_skills.get_agent_skill_registrations","title":"<code>get_agent_skill_registrations(agent: WaldieAgent, agent_names: Dict[str, str], all_skills: List[WaldieSkill], skill_names: Dict[str, str]) -&gt; str</code>","text":"<p>Get the agent skill registrations.</p> <p>example output:</p> <pre><code>&gt;&gt;&gt; register_function(\n    {skill_name},\n    caller={agent_name},\n    executor={executor_agent_name},\n    name=\"{skill_name}\",\n    description=\"{skill_description}\",\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <code>all_skills</code> <code>List[WaldieSkill]</code> <p>All the skills in the flow.</p> required <code>skill_names</code> <code>Dict[str, str]</code> <p>A mapping of skill id to skill name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The agent skill registrations.</p> Source code in <code>waldiez/exporting/agents/agent_skills.py</code> <pre><code>def get_agent_skill_registrations(\n    agent: WaldieAgent,\n    agent_names: Dict[str, str],\n    all_skills: List[WaldieSkill],\n    skill_names: Dict[str, str],\n) -&gt; str:\n    \"\"\"Get the agent skill registrations.\n\n    example output:\n\n    ```python\n    &gt;&gt;&gt; register_function(\n        {skill_name},\n        caller={agent_name},\n        executor={executor_agent_name},\n        name=\"{skill_name}\",\n        description=\"{skill_description}\",\n    )\n    ```\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n    all_skills : List[WaldieSkill]\n        All the skills in the flow.\n    skill_names : Dict[str, str]\n        A mapping of skill id to skill name.\n\n    Returns\n    -------\n    str\n        The agent skill registrations.\n    \"\"\"\n    if not agent.data.skills or not all_skills:\n        return \"\"\n    content = \"\"\n    for linked_skill in agent.data.skills:\n        skill_name = skill_names[linked_skill.id]\n        waldie_skill = next(\n            skill for skill in all_skills if skill.id == linked_skill.id\n        )\n        skill_description = (\n            waldie_skill.description or f\"Description of {skill_name}\"\n        )\n        skill_description = get_escaped_string(skill_description)\n        content += (\n            f\"register_function(\\n\"\n            f\"    {skill_name},\\n\"\n            f\"    caller={agent_names[agent.id]},\\n\"\n            f\"    executor={agent_names[linked_skill.executor_id]},\\n\"\n            f'    name=\"{skill_name}\",\\n'\n            f'    description=\"{skill_description}\",\\n'\n            f\")\\n\\n\"\n        )\n    return content\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agents.code_execution.get_agent_code_execution_config","title":"<code>get_agent_code_execution_config(agent: WaldieAgent, agent_name: str, skill_names: Dict[str, str]) -&gt; Tuple[str, str, str]</code>","text":"<p>Get the code execution config for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>agent_name</code> <code>str</code> <p>The agent name.</p> required <code>skill_names</code> <code>Dict[str, str]</code> <p>A mapping of skill id to skill name.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str, str, Set[str]]</code> <ul> <li>The executor content.</li> <li>The executor argument.</li> <li>The extra autogen.coding import if needed.</li> </ul> Source code in <code>waldiez/exporting/agents/code_execution.py</code> <pre><code>def get_agent_code_execution_config(\n    agent: WaldieAgent, agent_name: str, skill_names: Dict[str, str]\n) -&gt; Tuple[str, str, str]:\n    \"\"\"Get the code execution config for the agent.\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n    agent_name : str\n        The agent name.\n    skill_names : Dict[str, str]\n        A mapping of skill id to skill name.\n\n    Returns\n    -------\n    Tuple[str, str, str, Set[str]]\n        - The executor content.\n        - The executor argument.\n        - The extra autogen.coding import if needed.\n    \"\"\"\n    if agent.data.code_execution_config is False:\n        return \"\", \"False\", \"\"\n    use_docker = agent.data.code_execution_config.use_docker\n    if use_docker is None:\n        use_docker = False\n    executor_class_name = (\n        \"DockerCommandLineCodeExecutor\"\n        if use_docker\n        else \"LocalCommandLineCodeExecutor\"\n    )\n    executor_content = f\"{agent_name}_executor = {executor_class_name}(\\n\"\n    if agent.data.code_execution_config.work_dir:\n        wok_dir = agent.data.code_execution_config.work_dir.replace(\n            '\"', '\\\\\"'\n        ).replace(\"\\n\", \"\\\\n\")\n        executor_content += f'    work_dir=\"{wok_dir}\",\\n'\n    if agent.data.code_execution_config.timeout:\n        executor_content += (\n            f\"    timeout={agent.data.code_execution_config.timeout},\\n\"\n        )\n    if use_docker is False and agent.data.code_execution_config.functions:\n        function_names = []\n        for skill_id in agent.data.code_execution_config.functions:\n            skill_name = skill_names[skill_id]\n            function_names.append(skill_name)\n        if function_names:\n            # pylint: disable=inconsistent-quotes\n            executor_content += (\n                f\"    functions=[{', '.join(function_names)}],\\n\"\n            )\n    executor_content += \")\\n\\n\"\n    # if (\n    #     executor_content\n    #     == f\"{agent_name}_executor = {executor_class_name}(\\n)\\n\\n\"\n    # ):\n    #     # empty executor?\n    #     return \"\", \"False\", \"\"\n    executor_arg = f'{{\"executor\": {agent_name}_executor}}'\n    return executor_content, executor_arg, executor_class_name\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agents.group_manager.get_group_manager_extras","title":"<code>get_group_manager_extras(agent: WaldieAgent, group_chat_members: List[WaldieAgent], agent_names: Dict[str, str]) -&gt; Tuple[str, str]</code>","text":"<p>Get the group manager extra string and custom selection method if any.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>group_chat_members</code> <code>List[WaldieAgent]</code> <p>The group members.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>The agent names.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The content before the agent string and the group chat argument.</p> Source code in <code>waldiez/exporting/agents/group_manager.py</code> <pre><code>def get_group_manager_extras(\n    agent: WaldieAgent,\n    group_chat_members: List[WaldieAgent],\n    agent_names: Dict[str, str],\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the group manager extra string and custom selection method if any.\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n    group_chat_members : List[WaldieAgent]\n        The group members.\n    agent_names : Dict[str, str]\n        The agent names.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The content before the agent string and the group chat argument.\n    \"\"\"\n\n    group_chat_arg = \"\"\n    before_agent_string = \"\"\n    custom_speaker_selection: Optional[str] = None\n    if agent.agent_type == \"manager\" and isinstance(agent, WaldieGroupManager):\n        group_chat_string, group_chat_name, custom_speaker_selection = (\n            _get_group_manager_extras(agent, group_chat_members, agent_names)\n        )\n        if group_chat_name:\n            group_chat_arg = f\"\\n    groupchat={group_chat_name},\"\n        if custom_speaker_selection:\n            before_agent_string += f\"{custom_speaker_selection}\\n\\n\"\n        if group_chat_string:\n            before_agent_string += group_chat_string\n    return before_agent_string, group_chat_arg\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agents.llm_config.get_agent_llm_config","title":"<code>get_agent_llm_config(agent: WaldieAgent, model_names: Dict[str, str]) -&gt; str</code>","text":"<p>Get the llm config argument string for one agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>model_names</code> <code>Dict[str, str]</code> <p>A mapping of model id to model name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The llm config argument string.</p> Source code in <code>waldiez/exporting/agents/llm_config.py</code> <pre><code>def get_agent_llm_config(\n    agent: WaldieAgent,\n    model_names: Dict[str, str],\n) -&gt; str:\n    \"\"\"Get the llm config argument string for one agent.\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n    model_names : Dict[str, str]\n        A mapping of model id to model name.\n\n    Returns\n    -------\n    str\n        The llm config argument string.\n    \"\"\"\n    if not agent.data.model_ids:\n        # no models\n        return \"False\"\n    if len(agent.data.model_ids) == 1:\n        # one model\n        model_id = agent.data.model_ids[0]\n        model_name = model_names[model_id]\n        return model_name\n    output = '{\\n    \"config_list\": [\\n'\n    for model_id in agent.data.model_ids:\n        model_name = model_names[model_id]\n        output += f\"        {model_name},\\n\"\n    output += \"    ]\\n\" \"}\"\n    return output\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agents.termination_message.get_is_termination_message","title":"<code>get_is_termination_message(agent: WaldieAgent, agent_name: str) -&gt; Tuple[str, str]</code>","text":"<p>Get the <code>is_termination_message</code> argument and content (if any).</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>agent_name</code> <code>str</code> <p>The agent name.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <ul> <li>The termination function name or lambda or None.</li> <li>The termination function definition and content if any.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the termination type is invalid.</p> Source code in <code>waldiez/exporting/agents/termination_message.py</code> <pre><code>def get_is_termination_message(\n    agent: WaldieAgent, agent_name: str\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the `is_termination_message` argument and content (if any).\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n    agent_name : str\n        The agent name.\n\n    Returns\n    -------\n    Tuple[str, str]\n        - The termination function name or lambda or None.\n        - The termination function definition and content if any.\n\n    Raises\n    ------\n    ValueError\n        If the termination type is invalid.\n    \"\"\"\n    if agent.data.termination.type == \"none\":\n        return \"None\", \"\"\n    if agent.data.termination.type == \"keyword\":\n        return agent.data.termination.string, \"\"\n    if agent.data.termination.type == \"method\":\n        method_name = f\"is_termination_message_{agent_name}\"\n        content = (\n            \"\\n\\n\"\n            + f\"def is_termination_message_{agent_name}(message):\"\n            + \"\\n\"\n            + f\"{agent.data.termination.string}\"\n            + \"\\n\\n\"\n        )\n        return method_name, content\n    raise ValueError(f\"Invalid termination type: {agent.data.termination.type}\")\n</code></pre>"},{"location":"exporting/chats/","title":"Chats","text":"<p>Export the chats content.</p> <p>Nested chats exporting.</p>"},{"location":"exporting/chats/#waldiez.exporting.chats.chats.export_chats","title":"<code>export_chats(main_chats: List[Tuple[WaldieChat, WaldieAgent, WaldieAgent]], agent_names: Dict[str, str], chat_names: Dict[str, str], tabs: int) -&gt; Tuple[str, str]</code>","text":"<p>Get the chats content.</p> <p>Parameters:</p> Name Type Description Default <code>main_chats</code> <code>List[Tuple[WaldieChat, WaldieAgent, WaldieAgent]]</code> <p>The main flow chats.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <code>chat_names</code> <code>Dict[str, str]</code> <p>A mapping of chat id to chat name.</p> required <code>tabs</code> <code>int</code> <p>The number of tabs to use for indentation.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The chats content and additional methods string if any.</p> Source code in <code>waldiez/exporting/chats/chats.py</code> <pre><code>def export_chats(\n    main_chats: List[Tuple[WaldieChat, WaldieAgent, WaldieAgent]],\n    agent_names: Dict[str, str],\n    chat_names: Dict[str, str],\n    tabs: int,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the chats content.\n\n    Parameters\n    ----------\n    main_chats : List[Tuple[WaldieChat, WaldieAgent, WaldieAgent]]\n        The main flow chats.\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n    chat_names : Dict[str, str]\n        A mapping of chat id to chat name.\n    tabs : int\n        The number of tabs to use for indentation.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The chats content and additional methods string if any.\n    \"\"\"\n    if len(main_chats) == 1:\n        return export_single_chat_string(\n            flow=main_chats[0],\n            agent_names=agent_names,\n            chat_names=chat_names,\n            tabs=tabs,\n        )\n    return export_multiple_chats_string(\n        main_chats=main_chats,\n        chat_names=chat_names,\n        agent_names=agent_names,\n        tabs=tabs,\n    )\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.nested.export_nested_chat","title":"<code>export_nested_chat(agent: WaldieAgent, all_chats: List[WaldieChat], chat_names: Dict[str, str], agent_names: Dict[str, str]) -&gt; str</code>","text":"<p>Get the nested chat string.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>all_chats</code> <code>List[WaldieChat]</code> <p>All the chats in the flow.</p> required <code>chat_names</code> <code>Dict[str, str]</code> <p>The chat names.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>The agent names.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The nested chat string.</p> Source code in <code>waldiez/exporting/chats/nested.py</code> <pre><code>def export_nested_chat(\n    agent: WaldieAgent,\n    all_chats: List[WaldieChat],\n    chat_names: Dict[str, str],\n    agent_names: Dict[str, str],\n) -&gt; str:\n    \"\"\"Get the nested chat string.\n\n    Parameters\n    ----------\n    agent : WaldieAgent\n        The agent.\n    all_chats : List[WaldieChat]\n        All the chats in the flow.\n    chat_names : Dict[str, str]\n        The chat names.\n    agent_names : Dict[str, str]\n        The agent names.\n\n    Returns\n    -------\n    str\n        The nested chat string.\n    \"\"\"\n    if not agent.data.nested_chats:\n        return \"\"\n    content = \"\"\n    extra_contents = []\n    agent_name = agent_names[agent.id]\n    use_suffix = len(agent.data.nested_chats) &gt; 1\n    for index, entry in enumerate(agent.data.nested_chats):\n        trigger_names = get_nested_chat_trigger_agent_names(\n            all_chats=all_chats, nested_chat=entry, agent_names=agent_names\n        )\n        chat_queue, extra_methods = get_nested_chat_queue(\n            nested_chat=entry,\n            agent=agent,\n            agent_names=agent_names,\n            chat_names=chat_names,\n            all_chats=all_chats,\n        )\n        if not chat_queue:\n            continue\n        extra_contents.extend(extra_methods)\n        var_name = (\n            f\"{agent_name}_chat_queue_{index}\"\n            if use_suffix\n            else f\"{agent_name}_chat_queue\"\n        )\n        content += f\"\\n{var_name} = {chat_queue}\" + \"\\n\"\n        content += f\"\"\"\\n\n{agent_name}.register_nested_chats(\n    trigger={trigger_names},\n    chat_queue={var_name},\n)\\n\n\"\"\"\n    functions_string = \"\\n\".join(sorted(extra_contents))\n    if functions_string:\n        functions_string = functions_string + \"\\n\"\n    content = f\"{functions_string}{content}\"\n    return (\n        content.replace('\"None\"', \"None\")\n        .replace(\"'None'\", \"None\")\n        .replace('\"False\"', \"False\")\n        .replace(\"'False'\", \"False\")\n        .replace(\"'True'\", \"True\")\n        .replace('\"True\"', \"True\")\n    )\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.nested.get_chat_nested_string","title":"<code>get_chat_nested_string(chat: WaldieChat, is_reply: bool, chat_names: Dict[str, str]) -&gt; Tuple[str, Optional[str]]</code>","text":"<p>Get the nested chat message.</p> <p>Parameters:</p> Name Type Description Default <code>chat</code> <code>WaldieChat</code> <p>The chat.</p> required <code>is_reply</code> <code>bool</code> <p>Whether to use the nested chat's reply message or not.</p> required <code>chat_names</code> <code>Dict[str, str]</code> <p>A mapping of chat id to chat name</p> required <p>Returns:</p> Type Description <code>Tuple[str, Optional[str]]</code> <p>If the message is a string, the message content and None. If the message is a method, the method name and the method content. If the message is None, 'None' and None.</p> Source code in <code>waldiez/exporting/chats/nested.py</code> <pre><code>def get_chat_nested_string(\n    chat: WaldieChat,\n    is_reply: bool,\n    chat_names: Dict[str, str],\n) -&gt; Tuple[str, Optional[str]]:\n    \"\"\"Get the nested chat message.\n\n    Parameters\n    ----------\n    chat : WaldieChat\n        The chat.\n    is_reply : bool\n        Whether to use the nested chat's reply message or not.\n    chat_names : Dict[str, str]\n        A mapping of chat id to chat name\n\n    Returns\n    -------\n    Tuple[str, Optional[str]]\n        If the message is a string, the message content and None.\n        If the message is a method, the method name and the method content.\n        If the message is None, 'None' and None.\n    \"\"\"\n    message = (\n        chat.data.nested_chat.reply\n        if is_reply\n        else chat.data.nested_chat.message\n    )\n    if not message or message.type == \"none\" or message.content is None:\n        return \"None\", None\n    if message.type == \"string\":\n        return get_escaped_string(message.content), None\n    chat_name = chat_names[chat.id]\n    method_args = \"recipient, messages, sender, config\"\n    function_name = \"nested_chat_reply\" if is_reply else \"nested_chat_message\"\n    new_function_name = f\"{function_name}_{chat_name}\"\n    function_def = f\"\\ndef {new_function_name}({method_args}):\"\n    return new_function_name, function_def + \"\\n\" + message.content + \"\\n\"\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.nested.get_nested_chat_message_string","title":"<code>get_nested_chat_message_string(waldie_chat: WaldieChat, message: WaldieAgentNestedChatMessage, agent: WaldieAgent, agent_names: Dict[str, str], chat_names: Dict[str, str]) -&gt; Tuple[str, Optional[str]]</code>","text":"<p>Get the nested chat message string.</p> <p>Parameters:</p> Name Type Description Default <code>waldie_chat</code> <code>WaldieChat</code> <p>The chat.</p> required <code>message</code> <code>WaldieAgentNestedChatMessage</code> <p>The message.</p> required <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <code>chat_names</code> <code>Dict[str, str]</code> <p>A mapping of chat id to chat name.</p> required <p>Returns:</p> Type Description <code>Tuple[str, Optional[str]]</code> <p>The message string and the method name if the message is a method.</p> Source code in <code>waldiez/exporting/chats/nested.py</code> <pre><code>def get_nested_chat_message_string(\n    waldie_chat: WaldieChat,\n    message: WaldieAgentNestedChatMessage,\n    agent: WaldieAgent,\n    agent_names: Dict[str, str],\n    chat_names: Dict[str, str],\n) -&gt; Tuple[str, Optional[str]]:\n    \"\"\"Get the nested chat message string.\n\n    Parameters\n    ----------\n    waldie_chat : WaldieChat\n        The chat.\n    message : WaldieAgentNestedChatMessage\n        The message.\n    agent : WaldieAgent\n        The agent.\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n    chat_names : Dict[str, str]\n        A mapping of chat id to chat name.\n\n    Returns\n    -------\n    Tuple[str, Optional[str]]\n        The message string and the method name if the message is a method.\n    \"\"\"\n    sender_name: Optional[str] = None\n    sender_id = waldie_chat.target if message.is_reply else waldie_chat.source\n    recipient_id = (\n        waldie_chat.source if message.is_reply else waldie_chat.target\n    )\n    if sender_id != agent.id:\n        sender_name = agent_names[sender_id]\n    recipient_name = agent_names[recipient_id]\n    chat_dict = waldie_chat.get_chat_args()\n    chat_dict[\"recipient\"] = recipient_name\n    if sender_name:\n        chat_dict[\"sender\"] = sender_name\n    message_value, message_source = get_chat_nested_string(\n        chat=waldie_chat, is_reply=message.is_reply, chat_names=chat_names\n    )\n    chat_dict[\"message\"] = message_value\n    message_dict_str = get_object_string(chat_dict, tabs=1)\n    if message_source:\n        # it's not a string, its the name of the function\n        message_dict_str = message_dict_str.replace(\n            f': \"{message_value}\"', f\": {message_value}\"\n        )\n    if sender_name:\n        message_dict_str = message_dict_str.replace(\n            f': \"{sender_name}\"', f\": {sender_name}\"\n        )\n    if recipient_name:\n        message_dict_str = message_dict_str.replace(\n            f': \"{recipient_name}\"', f\": {recipient_name}\"\n        )\n    return message_dict_str, message_source\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.nested.get_nested_chat_queue","title":"<code>get_nested_chat_queue(nested_chat: WaldieAgentNestedChat, agent: WaldieAgent, agent_names: Dict[str, str], chat_names: Dict[str, str], all_chats: List[WaldieChat]) -&gt; Tuple[str, List[str]]</code>","text":"<p>Get the nested chat queue.</p> <p>Parameters:</p> Name Type Description Default <code>nested_chat</code> <code>WaldieAgentNestedChat</code> <p>The nested chat.</p> required <code>agent</code> <code>WaldieAgent</code> <p>The agent.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <code>chat_names</code> <code>Dict[str, str]</code> <p>A mapping of chat id to chat name.</p> required <code>all_chats</code> <code>List[WaldieChat]</code> <p>All the chats in the flow.</p> required <p>Returns:</p> Type Description <code>Tuple[str, List[str]]</code> <p>The nested chat queue and the methods to include.</p> Source code in <code>waldiez/exporting/chats/nested.py</code> <pre><code>def get_nested_chat_queue(\n    nested_chat: WaldieAgentNestedChat,\n    agent: WaldieAgent,\n    agent_names: Dict[str, str],\n    chat_names: Dict[str, str],\n    all_chats: List[WaldieChat],\n) -&gt; Tuple[str, List[str]]:\n    \"\"\"Get the nested chat queue.\n\n    Parameters\n    ----------\n    nested_chat : WaldieAgentNestedChat\n        The nested chat.\n    agent : WaldieAgent\n        The agent.\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n    chat_names : Dict[str, str]\n        A mapping of chat id to chat name.\n    all_chats : List[WaldieChat]\n        All the chats in the flow.\n\n    Returns\n    -------\n    Tuple[str, List[str]]\n        The nested chat queue and the methods to include.\n    \"\"\"\n    message_methods_to_include = []\n    chat_messages_str = \"[\\n\"\n    for message in nested_chat.messages:\n        waldie_chat = next(chat for chat in all_chats if chat.id == message.id)\n        message_str, message_source = get_nested_chat_message_string(\n            waldie_chat=waldie_chat,\n            message=message,\n            agent=agent,\n            agent_names=agent_names,\n            chat_names=chat_names,\n        )\n        if message_source:\n            message_methods_to_include.append(message_source)\n        chat_messages_str += f\"    {message_str},\" + \"\\n\"\n    chat_messages_str += \"]\"\n    if chat_messages_str == \"[\\n]\":\n        return \"\", message_methods_to_include\n    return chat_messages_str, message_methods_to_include\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.nested.get_nested_chat_trigger_agent_names","title":"<code>get_nested_chat_trigger_agent_names(all_chats: List[WaldieChat], nested_chat: WaldieAgentNestedChat, agent_names: Dict[str, str]) -&gt; str</code>","text":"<p>Get the trigger agent names for the nested chat.</p> <p>Parameters:</p> Name Type Description Default <code>all_chats</code> <code>List[WaldieChat]</code> <p>All the chats in the flow.</p> required <code>nested_chat</code> <code>WaldieAgentNestedChat</code> <p>The nested chat.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The trigger agent names.</p> Source code in <code>waldiez/exporting/chats/nested.py</code> <pre><code>def get_nested_chat_trigger_agent_names(\n    all_chats: List[WaldieChat],\n    nested_chat: WaldieAgentNestedChat,\n    agent_names: Dict[str, str],\n) -&gt; str:\n    \"\"\"Get the trigger agent names for the nested chat.\n\n    Parameters\n    ----------\n    all_chats : List[WaldieChat]\n        All the chats in the flow.\n    nested_chat : WaldieAgentNestedChat\n        The nested chat.\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n\n    Returns\n    -------\n    str\n        The trigger agent names.\n    \"\"\"\n    trigger_agent_ids: List[str] = []\n    for message in nested_chat.triggered_by:\n        waldie_chat = next(chat for chat in all_chats if chat.id == message.id)\n        if message.is_reply:\n            trigger_agent_ids.append(waldie_chat.target)\n        else:\n            trigger_agent_ids.append(waldie_chat.source)\n    agents = [agent_names[agent_id] for agent_id in trigger_agent_ids]\n    trigger_string = f'{[\", \".join(agents)]}'\n    return trigger_string.replace(\"'\", '\"')\n</code></pre>"},{"location":"exporting/flow/","title":"Flow","text":"<p>Export the entire flow to string.</p>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow.export_flow","title":"<code>export_flow(waldie: Waldie, agents: Tuple[List[WaldieAgent], Dict[str, str]], chats: Tuple[List[WaldieChat], Dict[str, str]], models: Tuple[List[WaldieModel], Dict[str, str]], skills: Tuple[List[WaldieSkill], Dict[str, str]], output_dir: Optional[Path], notebook: bool) -&gt; str</code>","text":"<p>Export the entire flow to a string.</p> <p>It contains the required imports, the model and skill definitions, the agent definitions, the links between agents, models and skills, the agents' nested chats, the chat definitions, and the actual call to start the chat(s).</p> <p>Parameters:</p> Name Type Description Default <code>waldie</code> <code>Waldie</code> <p>The Waldie instance.</p> required <code>agents</code> <code>Tuple[List[WaldieAgent], Dict[str, str]]</code> <p>The agents and their names.</p> required <code>chats</code> <code>Tuple[List[WaldieChat], Dict[str, str]]</code> <p>The chats and their names.</p> required <code>models</code> <code>Tuple[List[WaldieModel], Dict[str, str]]</code> <p>The models and their names.</p> required <code>skills</code> <code>Tuple[List[WaldieSkill], Dict[str, str]]</code> <p>The skills and their names.</p> required <code>output_dir</code> <code>Optional[Path]</code> <p>The output directory.</p> required <code>notebook</code> <code>bool</code> <p>Whether the export is for a jupyter notebook or a python script.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The flow string.</p> Source code in <code>waldiez/exporting/flow/flow.py</code> <pre><code>def export_flow(\n    waldie: Waldie,\n    agents: Tuple[List[WaldieAgent], Dict[str, str]],\n    chats: Tuple[List[WaldieChat], Dict[str, str]],\n    models: Tuple[List[WaldieModel], Dict[str, str]],\n    skills: Tuple[List[WaldieSkill], Dict[str, str]],\n    output_dir: Optional[Path],\n    notebook: bool,\n) -&gt; str:\n    \"\"\"Export the entire flow to a string.\n\n    It contains the required imports, the model and skill definitions,\n    the agent definitions, the links between agents, models and skills,\n    the agents' nested chats, the chat definitions, and the actual call\n    to start the chat(s).\n\n    Parameters\n    ----------\n    waldie : Waldie\n        The Waldie instance.\n    agents : Tuple[List[WaldieAgent], Dict[str, str]]\n        The agents and their names.\n    chats : Tuple[List[WaldieChat], Dict[str, str]]\n        The chats and their names.\n    models : Tuple[List[WaldieModel], Dict[str, str]]\n        The models and their names.\n    skills : Tuple[List[WaldieSkill], Dict[str, str]]\n        The skills and their names.\n    output_dir : Optional[Path]\n        The output directory.\n    notebook : bool\n        Whether the export is for a jupyter notebook or a python script.\n\n    Returns\n    -------\n    str\n        The flow string.\n    \"\"\"\n    all_agents, agent_names = agents\n    all_models, model_names = models\n    all_skills, skill_names = skills\n    all_chats, chat_names = chats\n    agent_strings = \"\"\n    # we need to add `skipped_agent_strings` after the other agents are defined\n    # for example, a group_manager needs the group members to have been defined\n    skipped_agent_strings = \"\"\n    nested_chats_strings = \"\"\n    builtin_imports: Set[str] = {\n        \"import csv\",\n        \"import os\",\n        \"import sqlite3\",\n    }\n    other_imports: Set[str] = {\n        \"from autogen import Agent\",\n        \"from autogen import ConversableAgent\",\n        \"from autogen import ChatResult\",\n        \"from autogen import runtime_logging\",\n    }\n    skill_imports, _ = export_skills(\n        skills=all_skills,\n        skill_names=skill_names,\n        output_dir=output_dir,\n    )\n    if len(waldie.chats) &gt; 1:\n        other_imports.add(\"from autogen import initiate_chats\")\n    for agent in all_agents:\n        agent_string, after_agent, agent_imports = export_agent(\n            agent=agent,\n            agent_names=agent_names,\n            model_names=model_names,\n            skill_names=skill_names,\n            all_skills=all_skills,\n            group_chat_members=waldie.flow.get_group_chat_members(agent.id),\n        )\n        other_imports.update(agent_imports)\n        if after_agent:\n            skipped_agent_strings += after_agent\n        if agent.agent_type == \"manager\":\n            skipped_agent_strings += agent_string\n        else:\n            agent_strings += agent_string\n        agent_nested_chats_string = export_nested_chat(\n            agent=agent,\n            agent_names=agent_names,\n            all_chats=all_chats,\n            chat_names=chat_names,\n        )\n        if agent_nested_chats_string:\n            nested_chats_strings += \"\\n\" + agent_nested_chats_string\n    agent_strings += skipped_agent_strings\n    all_imports_string = get_imports_string(\n        imports=other_imports,\n        builtin_imports=builtin_imports,\n        skill_imports=skill_imports,\n    )\n    return _combine_strings(\n        waldie=waldie,\n        imports_string=all_imports_string,\n        agents_string=agent_strings,\n        nested_chats_string=nested_chats_strings,\n        agent_names=agent_names,\n        all_models=all_models,\n        model_names=model_names,\n        chat_names=chat_names,\n        notebook=notebook,\n    )\n</code></pre>"},{"location":"exporting/models/","title":"Models","text":"<p>Model/LLM related string generation functions.</p> <p>Functions:</p> Name Description <code>export_models</code> <p>Get the string representations of the LLM configs.</p>"},{"location":"exporting/models/#waldiez.exporting.models.export_models","title":"<code>export_models(all_models: List[WaldieModel], model_names: Dict[str, str], notebook: bool) -&gt; str</code>","text":"<p>Get the string representations of the LLM configs.</p> <p>Parameters:</p> Name Type Description Default <code>all_models</code> <code>List[WaldieModel]</code> <p>The models.</p> required <code>model_names</code> <code>Dict[str, str]</code> <p>A mapping of model ids to model names.</p> required <code>notebook</code> <code>bool</code> <p>Whether to export the string for a jupyter notebook.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the LLM configs.</p> Example <pre><code>&gt;&gt;&gt; from waldiez.models import WaldieModel, WaldieModelData\n&gt;&gt;&gt; model = WaldieModel(\n...     id=\"wm-1\",\n...     name=\"llama3.1\"  ,\n...     description=\"A model for llamas :P.\",\n...     tags=[\"llama\", \"llama3.1\"],\n...     requirements=[],\n...     data=WaldieModelData(\n...         base_url=\"https://example.com/v1\",\n...         api_key=\"1234567890\",\n...         api_type=\"openai\",\n...         temperature=0.5,\n...         price={\n...             \"prompt_price_per_1k\": 0.0001,\n...             \"completion_token_price_per_1k\": 0.0002,\n...         },\n...     ),\n... )\n&gt;&gt;&gt; model_names = {\"wm-1\": \"llama3_1\"}\n&gt;&gt;&gt; export_models([model], model_names, True)\n\n# # Models\nllama3_1 = {\n    \"model\": \"llama3.1\",\n    \"base_url\": \"https://example.com/v1\",\n    \"api_key\": \"1234567890\",\n    \"api_type\": \"openai\",\n    \"temperature\": 0.5,\n    \"price\": [0.0001, 0.0002],\n}\n</code></pre> Source code in <code>waldiez/exporting/models/__init__.py</code> <pre><code>def export_models(\n    all_models: List[WaldieModel],\n    model_names: Dict[str, str],\n    notebook: bool,\n) -&gt; str:\n    \"\"\"Get the string representations of the LLM configs.\n\n    Parameters\n    ----------\n    all_models : List[WaldieModel]\n        The models.\n    model_names : Dict[str, str]\n        A mapping of model ids to model names.\n    notebook : bool\n        Whether to export the string for a jupyter notebook.\n\n    Returns\n    -------\n    str\n        The string representation of the LLM configs.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; from waldiez.models import WaldieModel, WaldieModelData\n    &gt;&gt;&gt; model = WaldieModel(\n    ...     id=\"wm-1\",\n    ...     name=\"llama3.1\"  ,\n    ...     description=\"A model for llamas :P.\",\n    ...     tags=[\"llama\", \"llama3.1\"],\n    ...     requirements=[],\n    ...     data=WaldieModelData(\n    ...         base_url=\"https://example.com/v1\",\n    ...         api_key=\"1234567890\",\n    ...         api_type=\"openai\",\n    ...         temperature=0.5,\n    ...         price={\n    ...             \"prompt_price_per_1k\": 0.0001,\n    ...             \"completion_token_price_per_1k\": 0.0002,\n    ...         },\n    ...     ),\n    ... )\n    &gt;&gt;&gt; model_names = {\"wm-1\": \"llama3_1\"}\n    &gt;&gt;&gt; export_models([model], model_names, True)\n\n    # # Models\n    llama3_1 = {\n        \"model\": \"llama3.1\",\n        \"base_url\": \"https://example.com/v1\",\n        \"api_key\": \"1234567890\",\n        \"api_type\": \"openai\",\n        \"temperature\": 0.5,\n        \"price\": [0.0001, 0.0002],\n    }\n    ```\n    \"\"\"\n    content = get_comment(\"models\", notebook) + \"\\n\"\n    if len(all_models) == 1:\n        model_name = model_names[all_models[0].id]\n        model_dict_str = get_object_string(all_models[0].llm_config, tabs=0)\n        content += f\"{model_name} = {model_dict_str}\\n\"\n        return content\n    for model in all_models:\n        model_name = model_names[model.id]\n        content += (\n            f\"{model_name} = {get_object_string(model.llm_config, tabs=0)}\\n\"\n        )\n    return content\n</code></pre>"},{"location":"exporting/skills/","title":"Skills","text":"<p>Skills/tools related string generation functions.</p> <p>Functions:</p> Name Description <code>get_agent_skill_registration</code> <p>Get an agent's skill registration string.</p> <code>export_skills</code> <p>Get the skills content and secrets.</p>"},{"location":"exporting/skills/#waldiez.exporting.skills.export_skills","title":"<code>export_skills(skills: List[WaldieSkill], skill_names: Dict[str, str], output_dir: Optional[Union[str, Path]] = None) -&gt; Tuple[Set[str], Set[Tuple[str, str]]]</code>","text":"<p>Get the skills' contents and secrets.</p> <p>If <code>output_dir</code> is provided, the contents are saved to that directory.</p> <p>Parameters:</p> Name Type Description Default <code>skills</code> <code>List[WaldieSkill]</code> <p>The skills.</p> required <code>skill_names</code> <code>Dict[str, str]</code> <p>The skill names.</p> required <code>output_dir</code> <code>Optional[Union[str, Path]]</code> <p>The output directory to save the skills to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Set[str], Set[Tuple[str, str]]]</code> <ul> <li>The skill imports to use in the main file.</li> <li>The skill secrets to set as environment variables.</li> </ul> Example <pre><code>&gt;&gt;&gt; from waldiez.models import WaldieSkill, WaldieSkillData\n&gt;&gt;&gt; skill1 = WaldieSkill(\n...     id=\"ws-1\",\n...     name=\"skill1\",\n...     description=\"A skill that does something.\",\n...     tags=[\"skill\", \"skill1\"],\n...     requirements=[],\n...     data=WaldieSkillData(\n...         content=\"def skill1():\\n    pass\",\n...         secrets={\"API_KEY\": \"1234567890\"},\n... )\n&gt;&gt;&gt; skill_names = {\"ws-1\": \"skill1\"}\n&gt;&gt;&gt; export_skills([skill1], skill_names, None)\n({'from skill1 import skill1'}, {('API_KEY', '1234567890')})\n</code></pre> Source code in <code>waldiez/exporting/skills/__init__.py</code> <pre><code>def export_skills(\n    skills: List[WaldieSkill],\n    skill_names: Dict[str, str],\n    output_dir: Optional[Union[str, Path]] = None,\n) -&gt; Tuple[Set[str], Set[Tuple[str, str]]]:\n    \"\"\"Get the skills' contents and secrets.\n\n    If `output_dir` is provided, the contents are saved to that directory.\n\n    Parameters\n    ----------\n    skills : List[WaldieSkill]\n        The skills.\n    skill_names : Dict[str, str]\n        The skill names.\n    output_dir : Optional[Union[str, Path]]\n        The output directory to save the skills to.\n\n    Returns\n    -------\n    Tuple[Set[str], Set[Tuple[str, str]]]\n        - The skill imports to use in the main file.\n        - The skill secrets to set as environment variables.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; from waldiez.models import WaldieSkill, WaldieSkillData\n    &gt;&gt;&gt; skill1 = WaldieSkill(\n    ...     id=\"ws-1\",\n    ...     name=\"skill1\",\n    ...     description=\"A skill that does something.\",\n    ...     tags=[\"skill\", \"skill1\"],\n    ...     requirements=[],\n    ...     data=WaldieSkillData(\n    ...         content=\"def skill1():\\\\n    pass\",\n    ...         secrets={\"API_KEY\": \"1234567890\"},\n    ... )\n    &gt;&gt;&gt; skill_names = {\"ws-1\": \"skill1\"}\n    &gt;&gt;&gt; export_skills([skill1], skill_names, None)\n    ({'from skill1 import skill1'}, {('API_KEY', '1234567890')})\n    ```\n    \"\"\"\n    skill_imports: Set[str] = set()\n    skill_secrets: Set[Tuple[str, str]] = set()\n    for skill in skills:\n        skill_name = skill_names[skill.id]\n        skill_imports.add(f\"from {skill_name} import {skill_name}\")\n        skill_secrets.update(skill.secrets.items())\n        if not output_dir:\n            continue\n        if not isinstance(output_dir, Path):\n            output_dir = Path(output_dir)\n        skill_file = output_dir / f\"{skill_name}.py\"\n        with skill_file.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(skill.content)\n    return skill_imports, skill_secrets\n</code></pre>"},{"location":"exporting/skills/#waldiez.exporting.skills.get_agent_skill_registration","title":"<code>get_agent_skill_registration(caller_name: str, executor_name: str, skill_name: str, skill_description: str) -&gt; str</code>","text":"<p>Get the agent skill string and secrets.</p> <p>Parameters:</p> Name Type Description Default <code>caller_name</code> <code>str</code> <p>The name of the caller (agent).</p> required <code>executor_name</code> <code>str</code> <p>The name of the executor (agent).</p> required <code>skill_name</code> <code>str</code> <p>The name of the skill.</p> required <code>skill_description</code> <code>str</code> <p>The skill description.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The agent skill string.</p> Example <pre><code>&gt;&gt;&gt; get_agent_skill_registration(\n...     caller_name=\"agent1\",\n...     executor_name=\"agent2\",\n...     skill_name=\"skill1\",\n...     skill_description=\"A skill that does something.\",\n... )\nregister_function(\n    skill1,\n    caller=agent1,\n    executor=agent2,\n    name=\"skill1\",\n    description=\"A skill that does something.\",\n)\n</code></pre> Source code in <code>waldiez/exporting/skills/__init__.py</code> <pre><code>def get_agent_skill_registration(\n    caller_name: str,\n    executor_name: str,\n    skill_name: str,\n    skill_description: str,\n) -&gt; str:\n    \"\"\"Get the agent skill string and secrets.\n\n    Parameters\n    ----------\n    caller_name : str\n        The name of the caller (agent).\n    executor_name : str\n        The name of the executor (agent).\n    skill_name : str\n        The name of the skill.\n    skill_description : str\n        The skill description.\n\n    Returns\n    -------\n    str\n        The agent skill string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_agent_skill_registration(\n    ...     caller_name=\"agent1\",\n    ...     executor_name=\"agent2\",\n    ...     skill_name=\"skill1\",\n    ...     skill_description=\"A skill that does something.\",\n    ... )\n    register_function(\n        skill1,\n        caller=agent1,\n        executor=agent2,\n        name=\"skill1\",\n        description=\"A skill that does something.\",\n    )\n    ```\n    \"\"\"\n    skill_description = get_escaped_string(skill_description)\n    content = f\"\"\"register_function(\n    {skill_name},\n    caller={caller_name},\n    executor={executor_name},\n    name=\"{skill_name}\",\n    description=\"{skill_description}\",\n)\"\"\"\n    return content\n</code></pre>"},{"location":"exporting/utils/","title":"Utils","text":"<p>Generic utils to be used for exporting.</p>"},{"location":"exporting/utils/#waldiez.exporting.utils.add_autogen_dot_import","title":"<code>add_autogen_dot_import(current_imports: Dict[str, List[str]], new_import: Tuple[str, str]) -&gt; Dict[str, List[str]]</code>","text":"<p>Add an autogen dot import (from autogen.{x} import {y}).</p> <p>Parameters:</p> Name Type Description Default <code>current_imports</code> <code>Dict[str, List[str]]</code> <p>The current autogen dot imports.</p> required <code>new_import</code> <code>Tuple[str, str]</code> <p>The new import.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>The updated imports.</p> Example <pre><code>&gt;&gt;&gt; current_imports = {\"a\": [\"b\", \"c\"], \"d\": [\"e\"]}\n&gt;&gt;&gt; new_import = (\"a\", \"f\")\n&gt;&gt;&gt; add_autogen_dot_import(current_imports, new_import)\n{'a': ['b', 'c', 'f'], 'd': ['e']}\n# and the final string would be:\nfrom autogen.a import b, c, f\nfrom autogen.d import e\n</code></pre> Source code in <code>waldiez/exporting/utils/importing.py</code> <pre><code>def add_autogen_dot_import(\n    current_imports: Dict[str, List[str]], new_import: Tuple[str, str]\n) -&gt; Dict[str, List[str]]:\n    \"\"\"Add an autogen dot import (from autogen.{x} import {y}).\n\n    Parameters\n    ----------\n    current_imports : Dict[str, List[str]]\n        The current autogen dot imports.\n    new_import : Tuple[str, str]\n        The new import.\n\n    Returns\n    -------\n    Dict[str, List[str]]\n        The updated imports.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; current_imports = {\"a\": [\"b\", \"c\"], \"d\": [\"e\"]}\n    &gt;&gt;&gt; new_import = (\"a\", \"f\")\n    &gt;&gt;&gt; add_autogen_dot_import(current_imports, new_import)\n    {'a': ['b', 'c', 'f'], 'd': ['e']}\n    # and the final string would be:\n    from autogen.a import b, c, f\n    from autogen.d import e\n    ```\n    \"\"\"\n    dot_part, module_part = new_import\n    if not module_part:\n        return current_imports\n    imports_copy = current_imports.copy()\n    if dot_part not in current_imports:\n        imports_copy[dot_part] = []\n    imports_copy[dot_part].append(module_part)\n    return imports_copy\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.comment","title":"<code>comment(notebook: bool, hashtags: int = 1) -&gt; str</code>","text":"<p>Get the comment string.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>bool</code> <p>Whether the comment is for a notebook or not.</p> required <code>hashtags</code> <code>int</code> <p>The number of hashtags (for notebooks), by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; comment(True, 2)\n'## '\n&gt;&gt;&gt; comment(False)\n'# '\n</code></pre> Source code in <code>waldiez/exporting/utils/comments.py</code> <pre><code>def comment(notebook: bool, hashtags: int = 1) -&gt; str:\n    \"\"\"Get the comment string.\n\n    Parameters\n    ----------\n    notebook : bool\n        Whether the comment is for a notebook or not.\n    hashtags : int, optional\n        The number of hashtags (for notebooks), by default 1.\n\n    Returns\n    -------\n    str\n        The comment string.\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; comment(True, 2)\n    '## '\n    &gt;&gt;&gt; comment(False)\n    '# '\n    ```\n    \"\"\"\n    content = \"# \"\n    if notebook:\n        content += \"#\" * hashtags + \" \"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.comments","title":"<code>comments</code>","text":"<p>Comment related string generation functions.</p> <p>Functions:</p> Name Description <code>comment</code> <p>Get a comment string.</p> <code>get_comment</code> <p>Get a comment string for some common keys (notebook headings).</p> <code>get_pylint_ignore_comment</code> <p>Get the pylint ignore comment string.</p>"},{"location":"exporting/utils/#waldiez.exporting.utils.comments.comment","title":"<code>comment(notebook: bool, hashtags: int = 1) -&gt; str</code>","text":"<p>Get the comment string.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>bool</code> <p>Whether the comment is for a notebook or not.</p> required <code>hashtags</code> <code>int</code> <p>The number of hashtags (for notebooks), by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; comment(True, 2)\n'## '\n&gt;&gt;&gt; comment(False)\n'# '\n</code></pre> Source code in <code>waldiez/exporting/utils/comments.py</code> <pre><code>def comment(notebook: bool, hashtags: int = 1) -&gt; str:\n    \"\"\"Get the comment string.\n\n    Parameters\n    ----------\n    notebook : bool\n        Whether the comment is for a notebook or not.\n    hashtags : int, optional\n        The number of hashtags (for notebooks), by default 1.\n\n    Returns\n    -------\n    str\n        The comment string.\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; comment(True, 2)\n    '## '\n    &gt;&gt;&gt; comment(False)\n    '# '\n    ```\n    \"\"\"\n    content = \"# \"\n    if notebook:\n        content += \"#\" * hashtags + \" \"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.comments.get_comment","title":"<code>get_comment(key: Literal['agents', 'skills', 'models', 'nested', 'run'], for_notebook: bool) -&gt; str</code>","text":"<p>Get a comment string for some common keys.</p> <p>The key is a heading (in a notebook) or just a comment (in a script).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Literal['agents', 'skills', 'models', 'nested', 'run']</code> <p>The key.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; get_comment(\"agents\", True)\n\n'## Agents'\n&gt;&gt;&gt; get_comment(\"skills\", False)\n\n'# Skills'\n</code></pre> Source code in <code>waldiez/exporting/utils/comments.py</code> <pre><code>def get_comment(\n    key: Literal[\"agents\", \"skills\", \"models\", \"nested\", \"run\"],\n    for_notebook: bool,\n) -&gt; str:\n    \"\"\"Get a comment string for some common keys.\n\n    The key is a heading (in a notebook) or just a comment (in a script).\n\n    Parameters\n    ----------\n    key : Literal[\"agents\", \"skills\", \"models\", \"nested\", \"run\"]\n        The key.\n    for_notebook : bool\n        Whether the comment is for a notebook.\n\n    Returns\n    -------\n    str\n        The comment string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_comment(\"agents\", True)\n\n    '## Agents'\n    &gt;&gt;&gt; get_comment(\"skills\", False)\n\n    '# Skills'\n    ```\n    \"\"\"\n    # mostly to make the caller a tiny bit more readable\n    if key == \"agents\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Agents\\n\"\n    if key == \"skills\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Skills\\n\"\n    if key == \"models\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Models\\n\"\n    if key == \"nested\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Nested Chats\\n\"\n    if key == \"run\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Run the flow\\n\"\n    return comment(for_notebook)\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.comments.get_pylint_ignore_comment","title":"<code>get_pylint_ignore_comment(notebook: bool, rules: Optional[List[str]] = None) -&gt; str</code>","text":"<p>Get the pylint ignore comment string.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>bool</code> <p>Whether the comment is for a notebook.</p> required <code>rules</code> <code>Optional[List[str]]</code> <p>The pylint rules to ignore, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The pylint ignore comment string.</p> Example <pre><code>&gt;&gt;&gt; get_pylint_ignore_comment(True, [\"invalid-name\", \"line-too-long\"])\n\n# pylint: disable=invalid-name, line-too-long\n</code></pre> Source code in <code>waldiez/exporting/utils/comments.py</code> <pre><code>def get_pylint_ignore_comment(\n    notebook: bool, rules: Optional[List[str]] = None\n) -&gt; str:\n    \"\"\"Get the pylint ignore comment string.\n\n    Parameters\n    ----------\n    notebook : bool\n        Whether the comment is for a notebook.\n    rules : Optional[List[str]], optional\n        The pylint rules to ignore, by default None.\n\n    Returns\n    -------\n    str\n        The pylint ignore comment string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_pylint_ignore_comment(True, [\"invalid-name\", \"line-too-long\"])\n\n    # pylint: disable=invalid-name, line-too-long\n    ```\n    \"\"\"\n    if not rules:\n        rules = PYLINT_RULES\n    line = \"# pylint: disable=\" + \", \".join(rules)\n    if notebook is True:\n        line = \"\\n\" + line\n    return line + \"\\n\"\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_comment","title":"<code>get_comment(key: Literal['agents', 'skills', 'models', 'nested', 'run'], for_notebook: bool) -&gt; str</code>","text":"<p>Get a comment string for some common keys.</p> <p>The key is a heading (in a notebook) or just a comment (in a script).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Literal['agents', 'skills', 'models', 'nested', 'run']</code> <p>The key.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; get_comment(\"agents\", True)\n\n'## Agents'\n&gt;&gt;&gt; get_comment(\"skills\", False)\n\n'# Skills'\n</code></pre> Source code in <code>waldiez/exporting/utils/comments.py</code> <pre><code>def get_comment(\n    key: Literal[\"agents\", \"skills\", \"models\", \"nested\", \"run\"],\n    for_notebook: bool,\n) -&gt; str:\n    \"\"\"Get a comment string for some common keys.\n\n    The key is a heading (in a notebook) or just a comment (in a script).\n\n    Parameters\n    ----------\n    key : Literal[\"agents\", \"skills\", \"models\", \"nested\", \"run\"]\n        The key.\n    for_notebook : bool\n        Whether the comment is for a notebook.\n\n    Returns\n    -------\n    str\n        The comment string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_comment(\"agents\", True)\n\n    '## Agents'\n    &gt;&gt;&gt; get_comment(\"skills\", False)\n\n    '# Skills'\n    ```\n    \"\"\"\n    # mostly to make the caller a tiny bit more readable\n    if key == \"agents\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Agents\\n\"\n    if key == \"skills\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Skills\\n\"\n    if key == \"models\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Models\\n\"\n    if key == \"nested\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Nested Chats\\n\"\n    if key == \"run\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Run the flow\\n\"\n    return comment(for_notebook)\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_escaped_string","title":"<code>get_escaped_string(string: str) -&gt; str</code>","text":"<p>Get a string with escaped quotes and newlines.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The escaped string.</p> Source code in <code>waldiez/exporting/utils/naming.py</code> <pre><code>def get_escaped_string(string: str) -&gt; str:\n    \"\"\"Get a string with escaped quotes and newlines.\n\n    Parameters\n    ----------\n    string : str\n        The original string.\n\n    Returns\n    -------\n    str\n        The escaped string.\n    \"\"\"\n    return string.replace('\"', '\\\\\"').replace(\"\\n\", \"\\\\n\")\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_imports_string","title":"<code>get_imports_string(imports: Set[str], skill_imports: Set[str], typing_imports: Optional[Set[str]] = None, builtin_imports: Optional[Set[str]] = None, other_imports: Optional[Set[str]] = None) -&gt; str</code>","text":"<p>Get the imports.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>Set[str]</code> <p>The flow imports (e.g. from autogen.{x[y.z]} import {w}).</p> required <code>skill_imports</code> <code>Set[str]</code> <p>The skill imports.</p> required <code>typing_imports</code> <code>Set[str]</code> <p>The typing imports, by default None.</p> <code>None</code> <code>builtin_imports</code> <code>Set[str]</code> <p>The builtin imports, by default None.</p> <code>None</code> <code>other_imports</code> <code>Set[str]</code> <p>Other third party imports, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The imports string.</p> Example <pre><code>&gt;&gt;&gt; autogen_imports = {\"from autogen import a\", \"from autogen.b import c\"}\n&gt;&gt;&gt; skill_imports = {\"from skill_name import skill_name\"}\n&gt;&gt;&gt; get_imports_string(autogen_imports, skill_imports)\n\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\nfrom typing_extensions import Annotated\n\nfrom autogen import a\nfrom autogen.b import c\n\nfrom skill_name import skill_name'\n</code></pre> Source code in <code>waldiez/exporting/utils/importing.py</code> <pre><code>def get_imports_string(\n    imports: Set[str],\n    skill_imports: Set[str],\n    typing_imports: Optional[Set[str]] = None,\n    builtin_imports: Optional[Set[str]] = None,\n    other_imports: Optional[Set[str]] = None,\n) -&gt; str:\n    \"\"\"Get the imports.\n\n    Parameters\n    ----------\n    imports : Set[str]\n        The flow imports (e.g. from autogen.{x[y.z]} import {w}).\n    skill_imports : Set[str]\n        The skill imports.\n    typing_imports : Set[str], optional\n        The typing imports, by default None.\n    builtin_imports : Set[str], optional\n        The builtin imports, by default None.\n    other_imports : Set[str], optional\n        Other third party imports, by default None.\n\n    Returns\n    -------\n    str\n        The imports string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; autogen_imports = {\"from autogen import a\", \"from autogen.b import c\"}\n    &gt;&gt;&gt; skill_imports = {\"from skill_name import skill_name\"}\n    &gt;&gt;&gt; get_imports_string(autogen_imports, skill_imports)\n\n    from typing import Any, Callable, Dict, List, Optional, Tuple, Union\n    from typing_extensions import Annotated\n\n    from autogen import a\n    from autogen.b import c\n\n    from skill_name import skill_name'\n    ```\n    \"\"\"\n    if not typing_imports:\n        typing_imports = DEFAULT_TYPING_IMPORTS\n    if not builtin_imports:\n        builtin_imports = set()\n    if not other_imports:\n        other_imports = set()\n    string = _get_builtin_imports_string(builtin_imports, typing_imports)\n    string += _get_third_party_imports_string(imports, other_imports)\n    string += _get_skill_imports_string(skill_imports)\n    string = \"\\n\\n\".join([line for line in string.split(\"\\n\\n\") if line])\n    while not string.endswith(\"\\n\\n\"):\n        string += \"\\n\"\n    return string\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_logging_start_string","title":"<code>get_logging_start_string(tabs: int = 0) -&gt; str</code>","text":"<p>Get the logging start string.</p> <p>Parameters:</p> Name Type Description Default <code>tabs</code> <code>int</code> <p>The number of tabs to use for indentation, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The logging start string.</p> Example <pre><code>&gt;&gt;&gt; get_logging_start_string()\nruntime_logging.start(\n    logger_type=\"sqlite\",\n    config={\"dbname\": \"flow.db\"},\n)\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_logging_start_string(tabs: int = 0) -&gt; str:\n    \"\"\"Get the logging start string.\n\n    Parameters\n    ----------\n    tabs : int, optional\n        The number of tabs to use for indentation, by default 0\n\n    Returns\n    -------\n    str\n        The logging start string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_logging_start_string()\n    runtime_logging.start(\n        logger_type=\"sqlite\",\n        config={\"dbname\": \"flow.db\"},\n    )\n    ```\n    \"\"\"\n    tab = \"    \" * tabs\n    content = f\"{tab}runtime_logging.start(\\n\"\n    content += f'{tab}    logger_type=\"sqlite\",\\n'\n    content += f'{tab}    config={{\"dbname\": \"flow.db\"}},\\n'\n    content += f\"{tab})\\n\"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_logging_stop_string","title":"<code>get_logging_stop_string(tabs: int = 0) -&gt; str</code>","text":"<p>Get the logging stop string.</p> <p>Parameters:</p> Name Type Description Default <code>tabs</code> <code>int</code> <p>The number of tabs to use for indentation, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The logging stop string</p> Example <pre><code>&gt;&gt;&gt; get_logging_stop_string()\nruntime_logging.stop()\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_logging_stop_string(tabs: int = 0) -&gt; str:\n    \"\"\"Get the logging stop string.\n\n    Parameters\n    ----------\n    tabs : int, optional\n        The number of tabs to use for indentation, by default 0\n\n    Returns\n    -------\n    str\n        The logging stop string\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_logging_stop_string()\n    runtime_logging.stop()\n    ```\n    \"\"\"\n    tab = \"    \" * tabs\n    return f\"{tab}runtime_logging.stop()\\n\"\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_method_string","title":"<code>get_method_string(method_name: WaldieMethodName, renamed_method_name: str, method_body: str) -&gt; str</code>","text":"<p>Get a function string.</p> <p>Parameters:</p> Name Type Description Default <code>method_name</code> <code>WaldieMethodName</code> <p>The method name.</p> required <code>renamed_method_name</code> <code>str</code> <p>The renamed method name.</p> required <code>method_body</code> <code>str</code> <p>The method body.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function string having the definition, type hints and body.</p> Source code in <code>waldiez/exporting/utils/method_utils.py</code> <pre><code>def get_method_string(\n    method_name: WaldieMethodName, renamed_method_name: str, method_body: str\n) -&gt; str:\n    \"\"\"Get a function string.\n\n    Parameters\n    ----------\n    method_name : WaldieMethodName\n        The method name.\n    renamed_method_name : str\n        The renamed method name.\n    method_body : str\n        The method body.\n\n    Returns\n    -------\n    str\n        The function string having the definition, type hints and body.\n    \"\"\"\n    method_args = METHOD_ARGS[method_name]\n    content = f\"def {renamed_method_name}(\"\n    if len(method_args) == 0:\n        content += \"):\"\n    else:\n        content += \"\\n\"\n        for arg in method_args:\n            content += f\"    {arg},\\n\"\n        content += \"):\"\n    content += f\"\\n{method_body}\"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_object_string","title":"<code>get_object_string(obj: Any, tabs: int = 1) -&gt; str</code>","text":"<p>Convert an object to a formatted string with given indentation.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to convert.</p> required <code>tabs</code> <code>int</code> <p>The number of tabs, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The formatted string.</p> Example <pre><code>&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n&gt;&gt;&gt; get_object_string(obj)\n{\n    \"a\": 1,\n    \"b\": [\n        1,\n        2,\n        3\n    ]\n}\n&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n&gt;&gt;&gt; get_object_string(obj, 2)\n{\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ],\n        \"c\": {\n            \"d\": 4\n        }\n}\n</code></pre> Source code in <code>waldiez/exporting/utils/object_string.py</code> <pre><code>def get_object_string(obj: Any, tabs: int = 1) -&gt; str:\n    \"\"\"Convert an object to a formatted string with given indentation.\n\n    Parameters\n    ----------\n    obj : Any\n        The object to convert.\n    tabs : int, optional\n        The number of tabs, by default 1.\n\n    Returns\n    -------\n    str\n        The formatted string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n    &gt;&gt;&gt; get_object_string(obj)\n    {\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ]\n    }\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n    &gt;&gt;&gt; get_object_string(obj, 2)\n    {\n            \"a\": 1,\n            \"b\": [\n                1,\n                2,\n                3\n            ],\n            \"c\": {\n                \"d\": 4\n            }\n    }\n    ```\n    \"\"\"\n    indent = \" \" * 4 * tabs  # Number of spaces corresponding to the tabs\n    next_indent = (\n        \" \" * 4 * (tabs + 1)\n    )  # Number of spaces corresponding to the next tab level\n    if isinstance(obj, dict):\n        items = []\n        for key, value in obj.items():\n            items.append(\n                f'{next_indent}\"{key}\": {get_object_string(value, tabs + 1)}'\n            )\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"{{{to_return}}}\"\n        # return f'{{\\n{\",\\n\".join(items)}\\n{indent}}}'\n    if isinstance(obj, list):\n        items = []\n        for item in obj:\n            items.append(f\"{next_indent}{get_object_string(item, tabs + 1)}\")\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"[{to_return}]\"\n\n    if isinstance(obj, str):\n        return f'\"{obj}\"'\n\n    if obj is None:\n        return \"None\"\n    return str(obj)\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_pylint_ignore_comment","title":"<code>get_pylint_ignore_comment(notebook: bool, rules: Optional[List[str]] = None) -&gt; str</code>","text":"<p>Get the pylint ignore comment string.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>bool</code> <p>Whether the comment is for a notebook.</p> required <code>rules</code> <code>Optional[List[str]]</code> <p>The pylint rules to ignore, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The pylint ignore comment string.</p> Example <pre><code>&gt;&gt;&gt; get_pylint_ignore_comment(True, [\"invalid-name\", \"line-too-long\"])\n\n# pylint: disable=invalid-name, line-too-long\n</code></pre> Source code in <code>waldiez/exporting/utils/comments.py</code> <pre><code>def get_pylint_ignore_comment(\n    notebook: bool, rules: Optional[List[str]] = None\n) -&gt; str:\n    \"\"\"Get the pylint ignore comment string.\n\n    Parameters\n    ----------\n    notebook : bool\n        Whether the comment is for a notebook.\n    rules : Optional[List[str]], optional\n        The pylint rules to ignore, by default None.\n\n    Returns\n    -------\n    str\n        The pylint ignore comment string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_pylint_ignore_comment(True, [\"invalid-name\", \"line-too-long\"])\n\n    # pylint: disable=invalid-name, line-too-long\n    ```\n    \"\"\"\n    if not rules:\n        rules = PYLINT_RULES\n    line = \"# pylint: disable=\" + \", \".join(rules)\n    if notebook is True:\n        line = \"\\n\" + line\n    return line + \"\\n\"\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_sqlite_to_csv_call_string","title":"<code>get_sqlite_to_csv_call_string(tabs: int = 0) -&gt; str</code>","text":"<p>Get the sqlite to csv conversion call string.</p> <p>Parameters:</p> Name Type Description Default <code>tabs</code> <code>int</code> <p>The number of tabs to use for indentation, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The sqlite to csv conversion call string.</p> Example <pre><code>&gt;&gt;&gt; get_sqlite_to_csv_call_string()\nif not os.path.exists(\"logs\"):\n    os.makedirs(\"logs\")\nfor table in [\n    \"chat_completions\",\n    \"agents\",\n    \"oai_wrappers\",\n    \"oai_clients\",\n    \"version\",\n    \"events\",\n    \"function_calls\",\n]:\n    dest = os.path.join(\"logs\", f\"{table}.csv\")\n    sqlite_to_csv(\"flow.db\", table, dest)\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_sqlite_to_csv_call_string(tabs: int = 0) -&gt; str:\n    \"\"\"Get the sqlite to csv conversion call string.\n\n    Parameters\n    ----------\n    tabs : int, optional\n        The number of tabs to use for indentation, by default 0\n\n    Returns\n    -------\n    str\n        The sqlite to csv conversion call string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_sqlite_to_csv_call_string()\n    if not os.path.exists(\"logs\"):\n        os.makedirs(\"logs\")\n    for table in [\n        \"chat_completions\",\n        \"agents\",\n        \"oai_wrappers\",\n        \"oai_clients\",\n        \"version\",\n        \"events\",\n        \"function_calls\",\n    ]:\n        dest = os.path.join(\"logs\", f\"{table}.csv\")\n        sqlite_to_csv(\"flow.db\", table, dest)\n    ```\n    \"\"\"\n    table_names = [\n        \"chat_completions\",\n        \"agents\",\n        \"oai_wrappers\",\n        \"oai_clients\",\n        \"version\",\n        \"events\",\n        \"function_calls\",\n    ]\n    tab = \"    \" * tabs\n    content = \"\"\n    content += tab + 'if not os.path.exists(\"logs\"):\\n'\n    content += tab + '    os.makedirs(\"logs\")\\n'\n    content += tab + \"for table in [\\n\"\n    for table in table_names:\n        content += tab + f'    \"{table}\",\\n'\n    content += tab + \"]:\\n\"\n    content += tab + '    dest = os.path.join(\"logs\", f\"{table}.csv\")\\n'\n    content += tab + '    sqlite_to_csv(\"flow.db\", table, dest)\\n'\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_sqlite_to_csv_string","title":"<code>get_sqlite_to_csv_string() -&gt; str</code>","text":"<p>Get the sqlite to csv conversion code string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The sqlite to csv conversion code string.</p> Example <pre><code>&gt;&gt;&gt; get_sqlite_to_csv_string()\ndef sqlite_to_csv(dbname: str, table: str, csv_file: str) -&gt; None:\n    \"\"\"Convert a sqlite table to a csv file.\n\n    Parameters\n    ----------\n    dbname : str\n        The sqlite database name.\n    table : str\n        The table name.\n    csv_file : str\n        The csv file name.\n    \"\"\"\n    conn = sqlite3.connect(dbname)\n    query = f\"SELECT * FROM {table}\"  # nosec\n    cursor = conn.execute(query)\n    rows = cursor.fetchall()\n    column_names = [description[0] for description in cursor.description]\n    data = [dict(zip(column_names, row)) for row in rows]\n    conn.close()\n    with open(csv_file, \"w\", newline=\"\", encoding=\"utf-8\") as file:\n        _csv_writer = csv.DictWriter(file, fieldnames=column_names)\n        _csv_writer.writeheader()\n        _csv_writer.writerows(data)\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_sqlite_to_csv_string() -&gt; str:\n    \"\"\"Get the sqlite to csv conversion code string.\n\n    Returns\n    -------\n    str\n        The sqlite to csv conversion code string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_sqlite_to_csv_string()\n    def sqlite_to_csv(dbname: str, table: str, csv_file: str) -&gt; None:\n        \\\"\\\"\\\"Convert a sqlite table to a csv file.\n\n        Parameters\n        ----------\n        dbname : str\n            The sqlite database name.\n        table : str\n            The table name.\n        csv_file : str\n            The csv file name.\n        \\\"\\\"\\\"\n        conn = sqlite3.connect(dbname)\n        query = f\"SELECT * FROM {table}\"  # nosec\n        cursor = conn.execute(query)\n        rows = cursor.fetchall()\n        column_names = [description[0] for description in cursor.description]\n        data = [dict(zip(column_names, row)) for row in rows]\n        conn.close()\n        with open(csv_file, \"w\", newline=\"\", encoding=\"utf-8\") as file:\n            _csv_writer = csv.DictWriter(file, fieldnames=column_names)\n            _csv_writer.writeheader()\n            _csv_writer.writerows(data)\n    ```\n    \"\"\"\n    content = \"\\n\\n\"\n    content += (\n        \"def sqlite_to_csv(dbname: str, table: str, csv_file: str) -&gt; None:\\n\"\n    )\n    content += '    \"\"\"Convert a sqlite table to a csv file.\\n\\n'\n    content += \"    Parameters\\n\"\n    content += \"    ----------\\n\"\n    content += \"    dbname : str\\n\"\n    content += \"        The sqlite database name.\\n\"\n    content += \"    table : str\\n\"\n    content += \"        The table name.\\n\"\n    content += \"    csv_file : str\\n\"\n    content += \"        The csv file name.\\n\"\n    content += '    \"\"\"\\n'\n    content += \"    conn = sqlite3.connect(dbname)\\n\"\n    content += '    query = f\"SELECT * FROM {table}\"  # nosec\\n'\n    content += \"    cursor = conn.execute(query)\\n\"\n    content += \"    rows = cursor.fetchall()\\n\"\n    content += \"    column_names = [description[0] for description \"\n    content += \"in cursor.description]\\n\"\n    content += \"    data = [dict(zip(column_names, row)) for row in rows]\\n\"\n    content += \"    conn.close()\\n\"\n    content += (\n        '    with open(csv_file, \"w\", newline=\"\", encoding=\"utf-8\") as file:\\n'\n    )\n    content += (\n        \"        _csv_writer = csv.DictWriter(file, fieldnames=column_names)\\n\"\n    )\n    content += \"        _csv_writer.writeheader()\\n\"\n    content += \"        _csv_writer.writerows(data)\\n\"\n    content += \"\\n\\n\"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_valid_instance_name","title":"<code>get_valid_instance_name(instance: Tuple[str, str], current_names: Dict[str, str], prefix: str = 'w') -&gt; Dict[str, str]</code>","text":"<p>Get a valid instance name.</p> <p>If the instance id is already in the current names nothing is done. If the name already exists in the current names,     the name is updated (with an index suffix).</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Tuple[str, str]</code> <p>The instance id and possible name.</p> required <code>current_names</code> <code>Dict[str, str]</code> <p>The current names.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use if the name starts with a digit, if the name is already in the current names, or if the name is already in the current names with an index suffix.</p> <code>'w'</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The updated names.</p> Source code in <code>waldiez/exporting/utils/naming.py</code> <pre><code>def get_valid_instance_name(\n    instance: Tuple[str, str],\n    current_names: Dict[str, str],\n    prefix: str = \"w\",\n) -&gt; Dict[str, str]:\n    \"\"\"Get a valid instance name.\n\n    If the instance id is already in the current names nothing is done.\n    If the name already exists in the current names,\n        the name is updated (with an index suffix).\n\n    Parameters\n    ----------\n    instance : Tuple[str, str]\n        The instance id and possible name.\n    current_names : Dict[str, str]\n        The current names.\n    prefix : str, optional\n        The prefix to use if the name starts with a digit,\n        if the name is already in the current names,\n        or if the name is already in the current names with an index suffix.\n\n    Returns\n    -------\n    Dict[str, str]\n        The updated names.\n    \"\"\"\n    instance_id, possible_name = instance\n    if instance_id in current_names:\n        return current_names\n    new_names = current_names.copy()\n    name = get_valid_python_variable_name(possible_name, prefix)\n    if name in current_names.values():\n        name = f\"{prefix}_{name}\"\n    if name in current_names.values():\n        index = 1\n        while f\"{name}_{index}\" in current_names.values():\n            index += 1\n        name = f\"{name}_{index}\"\n    new_names[instance_id] = name\n    return new_names\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.get_valid_python_variable_name","title":"<code>get_valid_python_variable_name(possible: str, prefix: str = 'w') -&gt; str</code>","text":"<p>Get a valid Python variable name from a possible name.</p> <p>Parameters:</p> Name Type Description Default <code>possible</code> <code>str</code> <p>The possible name.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use if the name starts with a digit or special character</p> <code>'w'</code> <p>Returns:</p> Type Description <code>str</code> <p>The valid Python variable name.</p> Source code in <code>waldiez/exporting/utils/naming.py</code> <pre><code>def get_valid_python_variable_name(\n    possible: str,\n    prefix: str = \"w\",\n) -&gt; str:\n    \"\"\"Get a valid Python variable name from a possible name.\n\n    Parameters\n    ----------\n    possible : str\n        The possible name.\n\n    prefix : str, optional\n        The prefix to use if the name starts with a digit or special character\n\n    Returns\n    -------\n    str\n        The valid Python variable name.\n    \"\"\"\n\n    def replacement(match: re.Match[str]) -&gt; str:\n        \"\"\"Get the replacement for the match.\n\n        Parameters\n        ----------\n        match : re.Match[str]\n            The match.\n\n        Returns\n        -------\n        str\n            The replacement\n        \"\"\"\n        if match.group(0) in [\"-&gt;\", \"=&gt;\"]:\n            return \"to\"\n        if match.group(0) in [\"&lt;-\", \"&lt;=\"]:\n            return \"from\"\n        if re.match(r\"\\W|^(?=\\d)\", match.group(0)):\n            return \"_\"\n        return match.group(0)\n\n    possible = re.sub(r\"-&gt;|=&gt;|&lt;-|&lt;=|\\W|^(?=\\d)\", replacement, possible)[\n        :64\n    ].lower()\n\n    if not possible:\n        return prefix + \"_\"\n    if possible.startswith(\"_\"):\n        return f\"{prefix}{possible}\"\n    if possible[0].isdigit():\n        return f\"{prefix}_{possible}\"\n    return possible\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.importing","title":"<code>importing</code>","text":"<p>Importing related string generation functions.</p> <p>Functions:</p> Name Description <code>add_autogen_dot_import</code> <p>Add an autogen dot import (from autogen.{x.y} import {z}).</p> <code>get_imports_string</code> <p>Get the imports for the whole file/flow.</p>"},{"location":"exporting/utils/#waldiez.exporting.utils.importing.add_autogen_dot_import","title":"<code>add_autogen_dot_import(current_imports: Dict[str, List[str]], new_import: Tuple[str, str]) -&gt; Dict[str, List[str]]</code>","text":"<p>Add an autogen dot import (from autogen.{x} import {y}).</p> <p>Parameters:</p> Name Type Description Default <code>current_imports</code> <code>Dict[str, List[str]]</code> <p>The current autogen dot imports.</p> required <code>new_import</code> <code>Tuple[str, str]</code> <p>The new import.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>The updated imports.</p> Example <pre><code>&gt;&gt;&gt; current_imports = {\"a\": [\"b\", \"c\"], \"d\": [\"e\"]}\n&gt;&gt;&gt; new_import = (\"a\", \"f\")\n&gt;&gt;&gt; add_autogen_dot_import(current_imports, new_import)\n{'a': ['b', 'c', 'f'], 'd': ['e']}\n# and the final string would be:\nfrom autogen.a import b, c, f\nfrom autogen.d import e\n</code></pre> Source code in <code>waldiez/exporting/utils/importing.py</code> <pre><code>def add_autogen_dot_import(\n    current_imports: Dict[str, List[str]], new_import: Tuple[str, str]\n) -&gt; Dict[str, List[str]]:\n    \"\"\"Add an autogen dot import (from autogen.{x} import {y}).\n\n    Parameters\n    ----------\n    current_imports : Dict[str, List[str]]\n        The current autogen dot imports.\n    new_import : Tuple[str, str]\n        The new import.\n\n    Returns\n    -------\n    Dict[str, List[str]]\n        The updated imports.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; current_imports = {\"a\": [\"b\", \"c\"], \"d\": [\"e\"]}\n    &gt;&gt;&gt; new_import = (\"a\", \"f\")\n    &gt;&gt;&gt; add_autogen_dot_import(current_imports, new_import)\n    {'a': ['b', 'c', 'f'], 'd': ['e']}\n    # and the final string would be:\n    from autogen.a import b, c, f\n    from autogen.d import e\n    ```\n    \"\"\"\n    dot_part, module_part = new_import\n    if not module_part:\n        return current_imports\n    imports_copy = current_imports.copy()\n    if dot_part not in current_imports:\n        imports_copy[dot_part] = []\n    imports_copy[dot_part].append(module_part)\n    return imports_copy\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.importing.get_imports_string","title":"<code>get_imports_string(imports: Set[str], skill_imports: Set[str], typing_imports: Optional[Set[str]] = None, builtin_imports: Optional[Set[str]] = None, other_imports: Optional[Set[str]] = None) -&gt; str</code>","text":"<p>Get the imports.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>Set[str]</code> <p>The flow imports (e.g. from autogen.{x[y.z]} import {w}).</p> required <code>skill_imports</code> <code>Set[str]</code> <p>The skill imports.</p> required <code>typing_imports</code> <code>Set[str]</code> <p>The typing imports, by default None.</p> <code>None</code> <code>builtin_imports</code> <code>Set[str]</code> <p>The builtin imports, by default None.</p> <code>None</code> <code>other_imports</code> <code>Set[str]</code> <p>Other third party imports, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The imports string.</p> Example <pre><code>&gt;&gt;&gt; autogen_imports = {\"from autogen import a\", \"from autogen.b import c\"}\n&gt;&gt;&gt; skill_imports = {\"from skill_name import skill_name\"}\n&gt;&gt;&gt; get_imports_string(autogen_imports, skill_imports)\n\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\nfrom typing_extensions import Annotated\n\nfrom autogen import a\nfrom autogen.b import c\n\nfrom skill_name import skill_name'\n</code></pre> Source code in <code>waldiez/exporting/utils/importing.py</code> <pre><code>def get_imports_string(\n    imports: Set[str],\n    skill_imports: Set[str],\n    typing_imports: Optional[Set[str]] = None,\n    builtin_imports: Optional[Set[str]] = None,\n    other_imports: Optional[Set[str]] = None,\n) -&gt; str:\n    \"\"\"Get the imports.\n\n    Parameters\n    ----------\n    imports : Set[str]\n        The flow imports (e.g. from autogen.{x[y.z]} import {w}).\n    skill_imports : Set[str]\n        The skill imports.\n    typing_imports : Set[str], optional\n        The typing imports, by default None.\n    builtin_imports : Set[str], optional\n        The builtin imports, by default None.\n    other_imports : Set[str], optional\n        Other third party imports, by default None.\n\n    Returns\n    -------\n    str\n        The imports string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; autogen_imports = {\"from autogen import a\", \"from autogen.b import c\"}\n    &gt;&gt;&gt; skill_imports = {\"from skill_name import skill_name\"}\n    &gt;&gt;&gt; get_imports_string(autogen_imports, skill_imports)\n\n    from typing import Any, Callable, Dict, List, Optional, Tuple, Union\n    from typing_extensions import Annotated\n\n    from autogen import a\n    from autogen.b import c\n\n    from skill_name import skill_name'\n    ```\n    \"\"\"\n    if not typing_imports:\n        typing_imports = DEFAULT_TYPING_IMPORTS\n    if not builtin_imports:\n        builtin_imports = set()\n    if not other_imports:\n        other_imports = set()\n    string = _get_builtin_imports_string(builtin_imports, typing_imports)\n    string += _get_third_party_imports_string(imports, other_imports)\n    string += _get_skill_imports_string(skill_imports)\n    string = \"\\n\\n\".join([line for line in string.split(\"\\n\\n\") if line])\n    while not string.endswith(\"\\n\\n\"):\n        string += \"\\n\"\n    return string\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.logging_utils","title":"<code>logging_utils</code>","text":"<p>Logging related string generation functions.</p> <p>Functions:</p> Name Description <code>get_logging_start_string</code> <p>Get the string to start logging.</p> <code>get_logging_stop_string</code> <p>Get the string to stop logging.</p> <code>get_sqlite_to_csv_string</code> <p>Get the sqlite to csv conversion code string.</p> <code>get_sqlite_to_csv_call_string</code> <p>Get the string to call the sqlite to csv conversion.</p>"},{"location":"exporting/utils/#waldiez.exporting.utils.logging_utils.get_logging_start_string","title":"<code>get_logging_start_string(tabs: int = 0) -&gt; str</code>","text":"<p>Get the logging start string.</p> <p>Parameters:</p> Name Type Description Default <code>tabs</code> <code>int</code> <p>The number of tabs to use for indentation, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The logging start string.</p> Example <pre><code>&gt;&gt;&gt; get_logging_start_string()\nruntime_logging.start(\n    logger_type=\"sqlite\",\n    config={\"dbname\": \"flow.db\"},\n)\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_logging_start_string(tabs: int = 0) -&gt; str:\n    \"\"\"Get the logging start string.\n\n    Parameters\n    ----------\n    tabs : int, optional\n        The number of tabs to use for indentation, by default 0\n\n    Returns\n    -------\n    str\n        The logging start string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_logging_start_string()\n    runtime_logging.start(\n        logger_type=\"sqlite\",\n        config={\"dbname\": \"flow.db\"},\n    )\n    ```\n    \"\"\"\n    tab = \"    \" * tabs\n    content = f\"{tab}runtime_logging.start(\\n\"\n    content += f'{tab}    logger_type=\"sqlite\",\\n'\n    content += f'{tab}    config={{\"dbname\": \"flow.db\"}},\\n'\n    content += f\"{tab})\\n\"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.logging_utils.get_logging_stop_string","title":"<code>get_logging_stop_string(tabs: int = 0) -&gt; str</code>","text":"<p>Get the logging stop string.</p> <p>Parameters:</p> Name Type Description Default <code>tabs</code> <code>int</code> <p>The number of tabs to use for indentation, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The logging stop string</p> Example <pre><code>&gt;&gt;&gt; get_logging_stop_string()\nruntime_logging.stop()\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_logging_stop_string(tabs: int = 0) -&gt; str:\n    \"\"\"Get the logging stop string.\n\n    Parameters\n    ----------\n    tabs : int, optional\n        The number of tabs to use for indentation, by default 0\n\n    Returns\n    -------\n    str\n        The logging stop string\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_logging_stop_string()\n    runtime_logging.stop()\n    ```\n    \"\"\"\n    tab = \"    \" * tabs\n    return f\"{tab}runtime_logging.stop()\\n\"\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.logging_utils.get_sqlite_to_csv_call_string","title":"<code>get_sqlite_to_csv_call_string(tabs: int = 0) -&gt; str</code>","text":"<p>Get the sqlite to csv conversion call string.</p> <p>Parameters:</p> Name Type Description Default <code>tabs</code> <code>int</code> <p>The number of tabs to use for indentation, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The sqlite to csv conversion call string.</p> Example <pre><code>&gt;&gt;&gt; get_sqlite_to_csv_call_string()\nif not os.path.exists(\"logs\"):\n    os.makedirs(\"logs\")\nfor table in [\n    \"chat_completions\",\n    \"agents\",\n    \"oai_wrappers\",\n    \"oai_clients\",\n    \"version\",\n    \"events\",\n    \"function_calls\",\n]:\n    dest = os.path.join(\"logs\", f\"{table}.csv\")\n    sqlite_to_csv(\"flow.db\", table, dest)\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_sqlite_to_csv_call_string(tabs: int = 0) -&gt; str:\n    \"\"\"Get the sqlite to csv conversion call string.\n\n    Parameters\n    ----------\n    tabs : int, optional\n        The number of tabs to use for indentation, by default 0\n\n    Returns\n    -------\n    str\n        The sqlite to csv conversion call string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_sqlite_to_csv_call_string()\n    if not os.path.exists(\"logs\"):\n        os.makedirs(\"logs\")\n    for table in [\n        \"chat_completions\",\n        \"agents\",\n        \"oai_wrappers\",\n        \"oai_clients\",\n        \"version\",\n        \"events\",\n        \"function_calls\",\n    ]:\n        dest = os.path.join(\"logs\", f\"{table}.csv\")\n        sqlite_to_csv(\"flow.db\", table, dest)\n    ```\n    \"\"\"\n    table_names = [\n        \"chat_completions\",\n        \"agents\",\n        \"oai_wrappers\",\n        \"oai_clients\",\n        \"version\",\n        \"events\",\n        \"function_calls\",\n    ]\n    tab = \"    \" * tabs\n    content = \"\"\n    content += tab + 'if not os.path.exists(\"logs\"):\\n'\n    content += tab + '    os.makedirs(\"logs\")\\n'\n    content += tab + \"for table in [\\n\"\n    for table in table_names:\n        content += tab + f'    \"{table}\",\\n'\n    content += tab + \"]:\\n\"\n    content += tab + '    dest = os.path.join(\"logs\", f\"{table}.csv\")\\n'\n    content += tab + '    sqlite_to_csv(\"flow.db\", table, dest)\\n'\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.logging_utils.get_sqlite_to_csv_string","title":"<code>get_sqlite_to_csv_string() -&gt; str</code>","text":"<p>Get the sqlite to csv conversion code string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The sqlite to csv conversion code string.</p> Example <pre><code>&gt;&gt;&gt; get_sqlite_to_csv_string()\ndef sqlite_to_csv(dbname: str, table: str, csv_file: str) -&gt; None:\n    \"\"\"Convert a sqlite table to a csv file.\n\n    Parameters\n    ----------\n    dbname : str\n        The sqlite database name.\n    table : str\n        The table name.\n    csv_file : str\n        The csv file name.\n    \"\"\"\n    conn = sqlite3.connect(dbname)\n    query = f\"SELECT * FROM {table}\"  # nosec\n    cursor = conn.execute(query)\n    rows = cursor.fetchall()\n    column_names = [description[0] for description in cursor.description]\n    data = [dict(zip(column_names, row)) for row in rows]\n    conn.close()\n    with open(csv_file, \"w\", newline=\"\", encoding=\"utf-8\") as file:\n        _csv_writer = csv.DictWriter(file, fieldnames=column_names)\n        _csv_writer.writeheader()\n        _csv_writer.writerows(data)\n</code></pre> Source code in <code>waldiez/exporting/utils/logging_utils.py</code> <pre><code>def get_sqlite_to_csv_string() -&gt; str:\n    \"\"\"Get the sqlite to csv conversion code string.\n\n    Returns\n    -------\n    str\n        The sqlite to csv conversion code string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_sqlite_to_csv_string()\n    def sqlite_to_csv(dbname: str, table: str, csv_file: str) -&gt; None:\n        \\\"\\\"\\\"Convert a sqlite table to a csv file.\n\n        Parameters\n        ----------\n        dbname : str\n            The sqlite database name.\n        table : str\n            The table name.\n        csv_file : str\n            The csv file name.\n        \\\"\\\"\\\"\n        conn = sqlite3.connect(dbname)\n        query = f\"SELECT * FROM {table}\"  # nosec\n        cursor = conn.execute(query)\n        rows = cursor.fetchall()\n        column_names = [description[0] for description in cursor.description]\n        data = [dict(zip(column_names, row)) for row in rows]\n        conn.close()\n        with open(csv_file, \"w\", newline=\"\", encoding=\"utf-8\") as file:\n            _csv_writer = csv.DictWriter(file, fieldnames=column_names)\n            _csv_writer.writeheader()\n            _csv_writer.writerows(data)\n    ```\n    \"\"\"\n    content = \"\\n\\n\"\n    content += (\n        \"def sqlite_to_csv(dbname: str, table: str, csv_file: str) -&gt; None:\\n\"\n    )\n    content += '    \"\"\"Convert a sqlite table to a csv file.\\n\\n'\n    content += \"    Parameters\\n\"\n    content += \"    ----------\\n\"\n    content += \"    dbname : str\\n\"\n    content += \"        The sqlite database name.\\n\"\n    content += \"    table : str\\n\"\n    content += \"        The table name.\\n\"\n    content += \"    csv_file : str\\n\"\n    content += \"        The csv file name.\\n\"\n    content += '    \"\"\"\\n'\n    content += \"    conn = sqlite3.connect(dbname)\\n\"\n    content += '    query = f\"SELECT * FROM {table}\"  # nosec\\n'\n    content += \"    cursor = conn.execute(query)\\n\"\n    content += \"    rows = cursor.fetchall()\\n\"\n    content += \"    column_names = [description[0] for description \"\n    content += \"in cursor.description]\\n\"\n    content += \"    data = [dict(zip(column_names, row)) for row in rows]\\n\"\n    content += \"    conn.close()\\n\"\n    content += (\n        '    with open(csv_file, \"w\", newline=\"\", encoding=\"utf-8\") as file:\\n'\n    )\n    content += (\n        \"        _csv_writer = csv.DictWriter(file, fieldnames=column_names)\\n\"\n    )\n    content += \"        _csv_writer.writeheader()\\n\"\n    content += \"        _csv_writer.writerows(data)\\n\"\n    content += \"\\n\\n\"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.method_utils","title":"<code>method_utils</code>","text":"<p>Method related string generation utilities.</p>"},{"location":"exporting/utils/#waldiez.exporting.utils.method_utils.get_method_string","title":"<code>get_method_string(method_name: WaldieMethodName, renamed_method_name: str, method_body: str) -&gt; str</code>","text":"<p>Get a function string.</p> <p>Parameters:</p> Name Type Description Default <code>method_name</code> <code>WaldieMethodName</code> <p>The method name.</p> required <code>renamed_method_name</code> <code>str</code> <p>The renamed method name.</p> required <code>method_body</code> <code>str</code> <p>The method body.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function string having the definition, type hints and body.</p> Source code in <code>waldiez/exporting/utils/method_utils.py</code> <pre><code>def get_method_string(\n    method_name: WaldieMethodName, renamed_method_name: str, method_body: str\n) -&gt; str:\n    \"\"\"Get a function string.\n\n    Parameters\n    ----------\n    method_name : WaldieMethodName\n        The method name.\n    renamed_method_name : str\n        The renamed method name.\n    method_body : str\n        The method body.\n\n    Returns\n    -------\n    str\n        The function string having the definition, type hints and body.\n    \"\"\"\n    method_args = METHOD_ARGS[method_name]\n    content = f\"def {renamed_method_name}(\"\n    if len(method_args) == 0:\n        content += \"):\"\n    else:\n        content += \"\\n\"\n        for arg in method_args:\n            content += f\"    {arg},\\n\"\n        content += \"):\"\n    content += f\"\\n{method_body}\"\n    return content\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.naming","title":"<code>naming</code>","text":"<p>Naming related string generation functions.</p> <p>Functions:</p> Name Description <code>get_valid_python_variable_name</code> <p>Make sure a string is a valid Python variable name.</p> <code>get_valid_instance_name</code> <p>Get a valid instance name.</p> <code>get_escaped_string</code> <p>Get a string with escaped quotes and newlines.</p>"},{"location":"exporting/utils/#waldiez.exporting.utils.naming.get_escaped_string","title":"<code>get_escaped_string(string: str) -&gt; str</code>","text":"<p>Get a string with escaped quotes and newlines.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The escaped string.</p> Source code in <code>waldiez/exporting/utils/naming.py</code> <pre><code>def get_escaped_string(string: str) -&gt; str:\n    \"\"\"Get a string with escaped quotes and newlines.\n\n    Parameters\n    ----------\n    string : str\n        The original string.\n\n    Returns\n    -------\n    str\n        The escaped string.\n    \"\"\"\n    return string.replace('\"', '\\\\\"').replace(\"\\n\", \"\\\\n\")\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.naming.get_valid_instance_name","title":"<code>get_valid_instance_name(instance: Tuple[str, str], current_names: Dict[str, str], prefix: str = 'w') -&gt; Dict[str, str]</code>","text":"<p>Get a valid instance name.</p> <p>If the instance id is already in the current names nothing is done. If the name already exists in the current names,     the name is updated (with an index suffix).</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Tuple[str, str]</code> <p>The instance id and possible name.</p> required <code>current_names</code> <code>Dict[str, str]</code> <p>The current names.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use if the name starts with a digit, if the name is already in the current names, or if the name is already in the current names with an index suffix.</p> <code>'w'</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The updated names.</p> Source code in <code>waldiez/exporting/utils/naming.py</code> <pre><code>def get_valid_instance_name(\n    instance: Tuple[str, str],\n    current_names: Dict[str, str],\n    prefix: str = \"w\",\n) -&gt; Dict[str, str]:\n    \"\"\"Get a valid instance name.\n\n    If the instance id is already in the current names nothing is done.\n    If the name already exists in the current names,\n        the name is updated (with an index suffix).\n\n    Parameters\n    ----------\n    instance : Tuple[str, str]\n        The instance id and possible name.\n    current_names : Dict[str, str]\n        The current names.\n    prefix : str, optional\n        The prefix to use if the name starts with a digit,\n        if the name is already in the current names,\n        or if the name is already in the current names with an index suffix.\n\n    Returns\n    -------\n    Dict[str, str]\n        The updated names.\n    \"\"\"\n    instance_id, possible_name = instance\n    if instance_id in current_names:\n        return current_names\n    new_names = current_names.copy()\n    name = get_valid_python_variable_name(possible_name, prefix)\n    if name in current_names.values():\n        name = f\"{prefix}_{name}\"\n    if name in current_names.values():\n        index = 1\n        while f\"{name}_{index}\" in current_names.values():\n            index += 1\n        name = f\"{name}_{index}\"\n    new_names[instance_id] = name\n    return new_names\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.naming.get_valid_python_variable_name","title":"<code>get_valid_python_variable_name(possible: str, prefix: str = 'w') -&gt; str</code>","text":"<p>Get a valid Python variable name from a possible name.</p> <p>Parameters:</p> Name Type Description Default <code>possible</code> <code>str</code> <p>The possible name.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use if the name starts with a digit or special character</p> <code>'w'</code> <p>Returns:</p> Type Description <code>str</code> <p>The valid Python variable name.</p> Source code in <code>waldiez/exporting/utils/naming.py</code> <pre><code>def get_valid_python_variable_name(\n    possible: str,\n    prefix: str = \"w\",\n) -&gt; str:\n    \"\"\"Get a valid Python variable name from a possible name.\n\n    Parameters\n    ----------\n    possible : str\n        The possible name.\n\n    prefix : str, optional\n        The prefix to use if the name starts with a digit or special character\n\n    Returns\n    -------\n    str\n        The valid Python variable name.\n    \"\"\"\n\n    def replacement(match: re.Match[str]) -&gt; str:\n        \"\"\"Get the replacement for the match.\n\n        Parameters\n        ----------\n        match : re.Match[str]\n            The match.\n\n        Returns\n        -------\n        str\n            The replacement\n        \"\"\"\n        if match.group(0) in [\"-&gt;\", \"=&gt;\"]:\n            return \"to\"\n        if match.group(0) in [\"&lt;-\", \"&lt;=\"]:\n            return \"from\"\n        if re.match(r\"\\W|^(?=\\d)\", match.group(0)):\n            return \"_\"\n        return match.group(0)\n\n    possible = re.sub(r\"-&gt;|=&gt;|&lt;-|&lt;=|\\W|^(?=\\d)\", replacement, possible)[\n        :64\n    ].lower()\n\n    if not possible:\n        return prefix + \"_\"\n    if possible.startswith(\"_\"):\n        return f\"{prefix}{possible}\"\n    if possible[0].isdigit():\n        return f\"{prefix}_{possible}\"\n    return possible\n</code></pre>"},{"location":"exporting/utils/#waldiez.exporting.utils.object_string","title":"<code>object_string</code>","text":"<p>Function to convert an object to a formatted string with indentation.</p> <p>To be used with dicts and/or lists.</p>"},{"location":"exporting/utils/#waldiez.exporting.utils.object_string.get_object_string","title":"<code>get_object_string(obj: Any, tabs: int = 1) -&gt; str</code>","text":"<p>Convert an object to a formatted string with given indentation.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to convert.</p> required <code>tabs</code> <code>int</code> <p>The number of tabs, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The formatted string.</p> Example <pre><code>&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n&gt;&gt;&gt; get_object_string(obj)\n{\n    \"a\": 1,\n    \"b\": [\n        1,\n        2,\n        3\n    ]\n}\n&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n&gt;&gt;&gt; get_object_string(obj, 2)\n{\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ],\n        \"c\": {\n            \"d\": 4\n        }\n}\n</code></pre> Source code in <code>waldiez/exporting/utils/object_string.py</code> <pre><code>def get_object_string(obj: Any, tabs: int = 1) -&gt; str:\n    \"\"\"Convert an object to a formatted string with given indentation.\n\n    Parameters\n    ----------\n    obj : Any\n        The object to convert.\n    tabs : int, optional\n        The number of tabs, by default 1.\n\n    Returns\n    -------\n    str\n        The formatted string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n    &gt;&gt;&gt; get_object_string(obj)\n    {\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ]\n    }\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n    &gt;&gt;&gt; get_object_string(obj, 2)\n    {\n            \"a\": 1,\n            \"b\": [\n                1,\n                2,\n                3\n            ],\n            \"c\": {\n                \"d\": 4\n            }\n    }\n    ```\n    \"\"\"\n    indent = \" \" * 4 * tabs  # Number of spaces corresponding to the tabs\n    next_indent = (\n        \" \" * 4 * (tabs + 1)\n    )  # Number of spaces corresponding to the next tab level\n    if isinstance(obj, dict):\n        items = []\n        for key, value in obj.items():\n            items.append(\n                f'{next_indent}\"{key}\": {get_object_string(value, tabs + 1)}'\n            )\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"{{{to_return}}}\"\n        # return f'{{\\n{\",\\n\".join(items)}\\n{indent}}}'\n    if isinstance(obj, list):\n        items = []\n        for item in obj:\n            items.append(f\"{next_indent}{get_object_string(item, tabs + 1)}\")\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"[{to_return}]\"\n\n    if isinstance(obj, str):\n        return f'\"{obj}\"'\n\n    if obj is None:\n        return \"None\"\n    return str(obj)\n</code></pre>"},{"location":"models/chat/","title":"Chat","text":"<p>Waldie chat model.</p> <p>Chat data model.</p> <p>Waldie Message Model.</p> <p>Nested chat model.</p> <p>Waldie chat summary options.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat","title":"<code>WaldieChat</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Chat class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The chat ID.</p> <code>data</code> <code>WaldieChatData</code> <p>The chat data. See <code>waldiez.models.chat.WaldieChatData</code> for more information.</p> <code>name</code> <code>str</code> <p>The chat name.</p> <code>source</code> <code>str</code> <p>The chat source.</p> <code>target</code> <code>str</code> <p>The chat target.</p> <code>nested_chat</code> <code>WaldieChatNested</code> <p>The nested chat message/reply if any.</p> <code>message</code> <code>WaldieChatMessage</code> <p>The chat message.</p> <code>message_content</code> <code>Optional[str]</code> <p>The chat message content if any. If method, the method's body.</p> <p>Methods:</p> Name Description <code>get_chat_args</code> <p>Get the chat arguments to use in autogen.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat.get_chat_args","title":"<code>get_chat_args() -&gt; Dict[str, Any]</code>","text":"<p>Get the chat arguments to use in autogen.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The chat arguments.</p> Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def get_chat_args(self) -&gt; Dict[str, Any]:\n    \"\"\"Get the chat arguments to use in autogen.\n\n    Returns\n    -------\n    dict\n        The chat arguments.\n    \"\"\"\n    return self.data.get_chat_args()\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat.message","title":"<code>message: WaldieChatMessage</code>  <code>property</code>","text":"<p>Get the message.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat.message_content","title":"<code>message_content: Optional[str]</code>  <code>property</code>","text":"<p>Get the message content.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the name.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat.nested_chat","title":"<code>nested_chat: WaldieChatNested</code>  <code>property</code>","text":"<p>Get the nested chat.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat.source","title":"<code>source: str</code>  <code>property</code>","text":"<p>Get the source.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldieChat.target","title":"<code>target: str</code>  <code>property</code>","text":"<p>Get the target.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData","title":"<code>WaldieChatData</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Chat data class.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the chat.</p> <code>source</code> <code>str</code> <p>The source of the chat (sender).</p> <code>target</code> <code>str</code> <p>The target of the chat (recipient).</p> <code>description</code> <code>str</code> <p>The description of the chat.</p> <code>position</code> <code>int</code> <p>The position (order) of the chat. If negative, ignored.</p> <code>clear_history</code> <code>(Optional[bool], optional)</code> <p>Whether to clear the chat history, by default None.</p> <code>message</code> <code>Union[str, WaldieChatMessage]</code> <p>The message of the chat.</p> <code>message_context</code> <code>Dict[str, str]</code> <p>Additional context to be sent with the message.</p> <code>nested_chat</code> <code>WaldieChatNested</code> <p>The nested chat config.</p> <code>summary_method</code> <code>(Optional[WaldieChatSummaryMethod], optional)</code> <p>The summary method for the chat, by default None.</p> <code>llm_summary_method_options</code> <code>Optional[WaldieChatSummary]</code> <p>The LLM summary method options for the chat. Only used if the summary method is <code>reflection_with_llm</code></p> <code>max_turns</code> <code>Optional[int]</code> <p>The maximum number of turns for the chat, by default None (no limit).</p> <code>silent</code> <code>(Optional[bool], optional)</code> <p>Whether to run the chat silently, by default None (ignored).</p> <code>summary_args</code> <code>Optional[Dict[str, Any]]</code> <p>The summary args to use in autogen.</p> <p>Methods:</p> Name Description <code>validate_message</code> <p>Validate the message.</p> <code>validate_summary_method</code> <p>Validate the summary method.</p> <code>serialize_summary_method</code> <p>Serialize summary method.</p> <code>get_chat_args</code> <p>Get the chat arguments to use in autogen.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData.get_chat_args","title":"<code>get_chat_args() -&gt; Dict[str, Any]</code>","text":"<p>Get the chat arguments to use in autogen.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The dictionary to pass as kwargs.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>def get_chat_args(self) -&gt; Dict[str, Any]:\n    \"\"\"Get the chat arguments to use in autogen.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The dictionary to pass as kwargs.\n    \"\"\"\n    args: Dict[str, Any] = {}\n    if self.summary_method:\n        args[\"summary_method\"] = self.summary_method\n    if self.summary_args:\n        args[\"summary_args\"] = self.summary_args\n    if isinstance(self.max_turns, int) and self.max_turns &gt; 0:\n        args[\"max_turns\"] = self.max_turns\n    if isinstance(self.clear_history, bool):\n        args[\"clear_history\"] = self.clear_history\n    if isinstance(self.silent, bool):\n        args[\"silent\"] = self.silent\n    args.update(self._get_context_args())\n    return args\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData.message_content","title":"<code>message_content: Optional[str]</code>  <code>property</code>","text":"<p>Get the message content.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData.serialize_summary_method","title":"<code>serialize_summary_method(value: Any, info: FieldSerializationInfo) -&gt; Any</code>  <code>classmethod</code>","text":"<p>Serialize summary method.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to serialize.</p> required <code>info</code> <code>FieldSerializationInfo</code> <p>The serialization info.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The serialized value.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>@field_serializer(\"summary_method\")\n@classmethod\ndef serialize_summary_method(\n    cls, value: Any, info: FieldSerializationInfo\n) -&gt; Any:\n    \"\"\"Serialize summary method.\n\n    Parameters\n    ----------\n    value : Any\n        The value to serialize.\n    info : FieldSerializationInfo\n        The serialization info.\n\n    Returns\n    -------\n    Any\n        The serialized value.\n    \"\"\"\n    if info.by_alias is True:\n        if value == \"reflection_with_llm\":\n            return \"reflectionWithLlm\"\n        if value == \"last_msg\":\n            return \"lastMsg\"\n    return value\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData.summary_args","title":"<code>summary_args: Optional[Dict[str, Any]]</code>  <code>property</code>","text":"<p>Get the summary args.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData.validate_chat_data","title":"<code>validate_chat_data() -&gt; Self</code>","text":"<p>Validate the chat data.</p> <p>Returns:</p> Type Description <code>WaldieChatData</code> <p>The validated chat data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_chat_data(self) -&gt; Self:\n    \"\"\"Validate the chat data.\n\n    Returns\n    -------\n    WaldieChatData\n        The validated chat data.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if isinstance(self.message, WaldieChatMessage):\n        if self.message.type == \"none\":\n            self._message_content = None\n        elif self.message.type == \"string\":\n            self._message_content = self.message.content\n        else:\n            self._message_content = validate_message_dict(\n                value={\n                    \"type\": self.message.type,\n                    \"content\": self.message.content,\n                },\n                function_name=\"callable_message\",\n            ).content\n    return self\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData.validate_message","title":"<code>validate_message(value: Any) -&gt; WaldieChatMessage</code>  <code>classmethod</code>","text":"<p>Validate the message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The message value.</p> required <p>Returns:</p> Type Description <code>WaldieChatMessage</code> <p>The validated message value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>@field_validator(\"message\", mode=\"before\")\n@classmethod\ndef validate_message(cls, value: Any) -&gt; WaldieChatMessage:\n    \"\"\"Validate the message.\n\n    Parameters\n    ----------\n    value : Any\n        The message value.\n\n    Returns\n    -------\n    WaldieChatMessage\n        The validated message value.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if not value:\n        return WaldieChatMessage(type=\"none\", content=None)\n    if isinstance(value, str):\n        return WaldieChatMessage(type=\"string\", content=value)\n    if isinstance(value, dict):\n        message = validate_message_dict(\n            value, function_name=\"callable_message\"\n        )\n        return WaldieChatMessage(\n            type=message.type, content=value.get(\"content\")\n        )\n    if isinstance(value, WaldieChatMessage):\n        message = validate_message_dict(\n            value={\n                \"type\": value.type,\n                \"content\": value.content,\n            },\n            function_name=\"callable_message\",\n        )\n        return WaldieChatMessage(type=message.type, content=value.content)\n    return WaldieChatMessage(type=\"none\", content=None)\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldieChatData.validate_summary_method","title":"<code>validate_summary_method(value: Optional[WaldieChatSummaryMethod]) -&gt; Optional[WaldieChatSummaryMethod]</code>  <code>classmethod</code>","text":"<p>Validate the summary method.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[WaldieChatSummaryMethod]</code> <p>The passed WaldieChatSummaryMethod</p> required <p>Returns:</p> Type Description <code>Optional[WaldieChatSummaryMethod]</code> <p>The validated message summary method</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>@field_validator(\"summary_method\", mode=\"before\")\n@classmethod\ndef validate_summary_method(\n    cls, value: Optional[WaldieChatSummaryMethod]\n) -&gt; Optional[WaldieChatSummaryMethod]:\n    \"\"\"Validate the summary method.\n\n    Parameters\n    ----------\n    value : Optional[WaldieChatSummaryMethod]\n        The passed WaldieChatSummaryMethod\n\n    Returns\n    -------\n    Optional[WaldieChatSummaryMethod]\n        The validated message summary method\n    \"\"\"\n    if str(value).lower() == \"none\":\n        return None\n    if value == \"lastMsg\":\n        return \"last_msg\"\n    if value == \"reflectionWithLlm\":\n        return \"reflection_with_llm\"\n    return value\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_message.WaldieChatMessage","title":"<code>WaldieChatMessage</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Message.</p> <p>A generic message with a type and content.</p> <p>If the type is not 'none', the content is a string. If the type is 'method', the content is the source code of a method.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['string', 'method', 'none']</code> <p>The type of the message: string, method, or none.</p> <code>content</code> <code>Optional[str]</code> <p>The content of the message (string or method).</p>"},{"location":"models/chat/#waldiez.models.chat.chat_message.validate_message_dict","title":"<code>validate_message_dict(value: Dict[Literal['type', 'content'], Optional[str]], function_name: WaldieMethodName) -&gt; WaldieChatMessage</code>","text":"<p>Validate a message dict.</p> <p>Check the provided message dict. Depending on the type, the content is validated. If the type is \"method\", the content is checked against the function name.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>The message dict.</p> required <code>function_name</code> <code>str(WaldieMethodName)</code> <p>The function name.</p> required <p>Returns:</p> Type Description <code>WaldieChatMessage</code> <p>The validated message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_message.py</code> <pre><code>def validate_message_dict(\n    value: Dict[Literal[\"type\", \"content\"], Optional[str]],\n    function_name: WaldieMethodName,\n) -&gt; WaldieChatMessage:\n    \"\"\"Validate a message dict.\n\n    Check the provided message dict.\n    Depending on the type, the content is validated.\n    If the type is \"method\", the content is checked against the function name.\n\n    Parameters\n    ----------\n    value : dict\n        The message dict.\n    function_name : str (WaldieMethodName)\n        The function name.\n\n    Returns\n    -------\n    WaldieChatMessage\n        The validated message.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    message_type = value.get(\"type\")\n    content = value.get(\"content\")\n    if message_type == \"string\":\n        if not content:\n            raise ValueError(\n                \"The message content is required for the string type\"\n            )\n        return WaldieChatMessage(type=\"string\", content=content)\n    if message_type == \"none\":\n        return WaldieChatMessage(type=\"none\", content=None)\n    if message_type == \"method\":\n        if not content:\n            raise ValueError(\n                \"The message content is required for the method type\"\n            )\n        valid, error_or_content = check_function(content, function_name)\n        if not valid:\n            raise ValueError(error_or_content)\n        return WaldieChatMessage(type=\"method\", content=error_or_content)\n    raise ValueError(\"Invalid message type\")\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_nested.WaldieChatNested","title":"<code>WaldieChatNested</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Nested chat class.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>WaldieChatMessage</code> <p>The message in a nested chat (sender -&gt; recipient).</p> <code>reply</code> <code>WaldieChatMessage</code> <p>The reply in a nested chat (recipient -&gt; sender).</p>"},{"location":"models/chat/#waldiez.models.chat.chat_nested.WaldieChatNested.validate_message","title":"<code>validate_message(value: Any, info: ValidationInfo) -&gt; WaldieChatMessage</code>  <code>classmethod</code>","text":"<p>Validate the message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value.</p> required <code>info</code> <code>ValidationInfo</code> <p>The validation info.</p> required <p>Returns:</p> Type Description <code>WaldieChatMessage</code> <p>The validated message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_nested.py</code> <pre><code>@field_validator(\"message\", \"reply\", mode=\"before\")\n@classmethod\ndef validate_message(\n    cls, value: Any, info: ValidationInfo\n) -&gt; WaldieChatMessage:\n    \"\"\"Validate the message.\n\n    Parameters\n    ----------\n    value : Any\n        The value.\n    info : ValidationInfo\n        The validation info.\n\n    Returns\n    -------\n    WaldieChatMessage\n        The validated message.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    function_name: WaldieMethodName = (\n        \"nested_chat_message\"\n        if info.field_name == \"message\"\n        else \"nested_chat_reply\"\n    )\n    if not value:\n        return WaldieChatMessage(type=\"none\", content=None)\n    if isinstance(value, str):\n        return WaldieChatMessage(type=\"string\", content=value)\n    if isinstance(value, dict):\n        return validate_message_dict(value, function_name=function_name)\n    if isinstance(value, WaldieChatMessage):\n        return validate_message_dict(\n            {\"type\": value.type, \"content\": value.content},\n            function_name=function_name,\n        )\n    raise ValueError(f\"Invalid message type: {type(value)}\")\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_summary.WaldieChatSummary","title":"<code>WaldieChatSummary</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Llm summary method options.</p> <p>Attributes:</p> Name Type Description <code>prompt</code> <code>str</code> <p>The prompt for the LLM summary method.</p> <code>args</code> <code>Optional[Dict[str, Any]]</code> <p>The additional arguments for the LLM summary method, by default None.</p>"},{"location":"models/common/","title":"Common","text":"<p>Common utils for all models.</p>"},{"location":"models/common/#waldiez.models.common.WaldieBase","title":"<code>WaldieBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model class to inherit from.</p> <p>It contains the default configuration for all models. It also <code>model_dumps</code> by alias by default.</p>"},{"location":"models/common/#waldiez.models.common.WaldieBase.model_dump","title":"<code>model_dump(**kwargs: Any) -&gt; Dict[str, Any]</code>","text":"<p>Dump the model to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The dictionary representation of the model.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Dump the model to a dictionary.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The dictionary representation of the model.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.WaldieBase.model_dump_json","title":"<code>model_dump_json(**kwargs: Any) -&gt; str</code>","text":"<p>Dump the model to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The JSON string.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump_json(self, **kwargs: Any) -&gt; str:\n    \"\"\"Dump the model to a JSON string.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    str\n        The JSON string.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump_json(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.base","title":"<code>base</code>","text":"<p>Base class to inherit from.</p>"},{"location":"models/common/#waldiez.models.common.base.WaldieBase","title":"<code>WaldieBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model class to inherit from.</p> <p>It contains the default configuration for all models. It also <code>model_dumps</code> by alias by default.</p>"},{"location":"models/common/#waldiez.models.common.base.WaldieBase.model_dump","title":"<code>model_dump(**kwargs: Any) -&gt; Dict[str, Any]</code>","text":"<p>Dump the model to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The dictionary representation of the model.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Dump the model to a dictionary.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The dictionary representation of the model.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.base.WaldieBase.model_dump_json","title":"<code>model_dump_json(**kwargs: Any) -&gt; str</code>","text":"<p>Dump the model to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The JSON string.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump_json(self, **kwargs: Any) -&gt; str:\n    \"\"\"Dump the model to a JSON string.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    str\n        The JSON string.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump_json(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.check_function","title":"<code>check_function(code_string: str, function_name: WaldieMethodName) -&gt; Tuple[bool, str]</code>","text":"<p>Check the function.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <code>function_name</code> <code>WaldieMethodName</code> <p>The expected function name.</p> required <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>If valid, True and the function body (only), no extra lines. If invalid, False and the error message.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def check_function(\n    code_string: str,\n    function_name: WaldieMethodName,\n) -&gt; Tuple[bool, str]:\n    \"\"\"Check the function.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n    function_name : WaldieMethodName\n        The expected function name.\n\n    Returns\n    -------\n    Tuple[bool, str]\n        If valid, True and the function body (only), no extra lines.\n        If invalid, False and the error message.\n    \"\"\"\n    error, tree = parse_code_string(code_string)\n    if error is not None or tree is None:\n        return False, error or \"Invalid code\"\n    if function_name not in METHOD_ARGS:\n        return False, f\"Invalid function name: {function_name}\"\n    expected_method_args = METHOD_ARGS[function_name]\n    return _get_function_body(\n        tree, code_string, function_name, expected_method_args\n    )\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils","title":"<code>method_utils</code>","text":"<p>Function related utilities.</p>"},{"location":"models/common/#waldiez.models.common.method_utils.check_function","title":"<code>check_function(code_string: str, function_name: WaldieMethodName) -&gt; Tuple[bool, str]</code>","text":"<p>Check the function.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <code>function_name</code> <code>WaldieMethodName</code> <p>The expected function name.</p> required <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>If valid, True and the function body (only), no extra lines. If invalid, False and the error message.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def check_function(\n    code_string: str,\n    function_name: WaldieMethodName,\n) -&gt; Tuple[bool, str]:\n    \"\"\"Check the function.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n    function_name : WaldieMethodName\n        The expected function name.\n\n    Returns\n    -------\n    Tuple[bool, str]\n        If valid, True and the function body (only), no extra lines.\n        If invalid, False and the error message.\n    \"\"\"\n    error, tree = parse_code_string(code_string)\n    if error is not None or tree is None:\n        return False, error or \"Invalid code\"\n    if function_name not in METHOD_ARGS:\n        return False, f\"Invalid function name: {function_name}\"\n    expected_method_args = METHOD_ARGS[function_name]\n    return _get_function_body(\n        tree, code_string, function_name, expected_method_args\n    )\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils.parse_code_string","title":"<code>parse_code_string(code_string: str) -&gt; Tuple[Optional[str], Optional[ast.Module]]</code>","text":"<p>Parse the code string.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[Module]]</code> <p>If valid, None and the ast module. If invalid, the error message and None.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def parse_code_string(\n    code_string: str,\n) -&gt; Tuple[Optional[str], Optional[ast.Module]]:\n    \"\"\"Parse the code string.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n\n    Returns\n    -------\n    Tuple[Optional[str], Optional[ast.Module]]\n        If valid, None and the ast module.\n        If invalid, the error message and None.\n    \"\"\"\n    # pylint: disable=broad-except\n    try:\n        tree = ast.parse(code_string)\n    except SyntaxError as e:\n        return f\"SyntaxError: {e}, in \\n{code_string}\", None\n    except BaseException as e:  # pragma: no cover\n        return f\"Invalid code: {e}, in \\n{code_string}\", None\n    return None, tree\n</code></pre>"},{"location":"models/common/#waldiez.models.common.parse_code_string","title":"<code>parse_code_string(code_string: str) -&gt; Tuple[Optional[str], Optional[ast.Module]]</code>","text":"<p>Parse the code string.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[Module]]</code> <p>If valid, None and the ast module. If invalid, the error message and None.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def parse_code_string(\n    code_string: str,\n) -&gt; Tuple[Optional[str], Optional[ast.Module]]:\n    \"\"\"Parse the code string.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n\n    Returns\n    -------\n    Tuple[Optional[str], Optional[ast.Module]]\n        If valid, None and the ast module.\n        If invalid, the error message and None.\n    \"\"\"\n    # pylint: disable=broad-except\n    try:\n        tree = ast.parse(code_string)\n    except SyntaxError as e:\n        return f\"SyntaxError: {e}, in \\n{code_string}\", None\n    except BaseException as e:  # pragma: no cover\n        return f\"Invalid code: {e}, in \\n{code_string}\", None\n    return None, tree\n</code></pre>"},{"location":"models/flow/","title":"Flow","text":"<p>Waldie flow model.</p> <p>Waldie flow data.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldieFlow","title":"<code>WaldieFlow</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Flow data class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the flow.</p> <code>type</code> <code>(Literal['flow'], optional)</code> <p>The type of the \"node\" in a graph: \"flow\".</p> <code>name</code> <code>str</code> <p>The name of the flow.</p> <code>description</code> <code>str</code> <p>The description of the flow.</p> <code>tags</code> <code>List[str]</code> <p>The tags of the flow.</p> <code>requirements</code> <code>List[str]</code> <p>The requirements of the flow.</p> <code>data</code> <code>WaldieFlowData</code> <p>The data of the flow. See <code>WaldieFlowData</code>.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldieFlow.get_agent_by_id","title":"<code>get_agent_by_id(agent_id: str) -&gt; WaldieAgent</code>","text":"<p>Get the agent by ID.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The ID of the agent.</p> required <p>Returns:</p> Type Description <code>WaldieAgent</code> <p>The agent.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the agent with the given ID is not found.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_agent_by_id(self, agent_id: str) -&gt; WaldieAgent:\n    \"\"\"Get the agent by ID.\n\n    Parameters\n    ----------\n    agent_id : str\n        The ID of the agent.\n\n    Returns\n    -------\n    WaldieAgent\n        The agent.\n\n    Raises\n    ------\n    ValueError\n        If the agent with the given ID is not found.\n    \"\"\"\n    for user in self.data.agents.users:\n        if user.id == agent_id:\n            return user\n    for assistant in self.data.agents.assistants:\n        if assistant.id == agent_id:\n            return assistant\n    for manager in self.data.agents.managers:\n        if manager.id == agent_id:\n            return manager\n    for rag_user in self.data.agents.rag_users:\n        if rag_user.id == agent_id:\n            return rag_user\n    raise ValueError(f\"Agent with ID {agent_id} not found.\")\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldieFlow.get_agent_connections","title":"<code>get_agent_connections(agent_id: str, all_chats: bool = True) -&gt; List[str]</code>","text":"<p>Get the agent connections.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The ID of the agent.</p> required <code>all_chats</code> <code>bool</code> <p>If True, get the connections from all the chats, otherwise get the connections from the ordered flow (main chat flow).</p> <code>True</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of agent ids that the agent with the given ID connects to.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_agent_connections(\n    self, agent_id: str, all_chats: bool = True\n) -&gt; List[str]:\n    \"\"\"Get the agent connections.\n\n    Parameters\n    ----------\n    agent_id : str\n        The ID of the agent.\n    all_chats : bool, optional\n        If True, get the connections from all the chats, otherwise\n        get the connections from the ordered flow (main chat flow).\n\n    Returns\n    -------\n    List[str]\n        The list of agent ids that the agent with the given ID connects to.\n    \"\"\"\n    connections = []\n    if all_chats:\n        for chat in self.data.chats:\n            if chat.source == agent_id:\n                connections.append(chat.target)\n            if chat.target == agent_id:\n                connections.append(chat.source)\n    else:\n        for _, source, target in self.ordered_flow:\n            if source.id == agent_id:\n                connections.append(target.id)\n            if target.id == agent_id:\n                connections.append(source.id)\n    return connections\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldieFlow.get_group_chat_members","title":"<code>get_group_chat_members(group_manager_id: str) -&gt; List[WaldieAgent]</code>","text":"<p>Get the group chat members.</p> <p>Parameters:</p> Name Type Description Default <code>group_manager_id</code> <code>str</code> <p>The ID of the group manager.</p> required <p>Returns:</p> Type Description <code>List[WaldieAgent]</code> <p>The list of group chat</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_group_chat_members(\n    self, group_manager_id: str\n) -&gt; List[WaldieAgent]:\n    \"\"\"Get the group chat members.\n\n    Parameters\n    ----------\n    group_manager_id : str\n        The ID of the group manager.\n\n    Returns\n    -------\n    List[WaldieAgent]\n        The list of group chat\n    \"\"\"\n    agent = self.get_agent_by_id(group_manager_id)\n    if agent.agent_type != \"manager\":\n        return []\n    connections = self.get_agent_connections(group_manager_id)\n    return [self.get_agent_by_id(member_id) for member_id in connections]\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldieFlow.ordered_flow","title":"<code>ordered_flow: List[Tuple[WaldieChat, WaldieAgent, WaldieAgent]]</code>  <code>property</code>","text":"<p>Get the ordered flow.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldieFlow.validate_flow","title":"<code>validate_flow() -&gt; Self</code>","text":"<p>Flow validation.</p> <ul> <li>unique node ids</li> <li>there are at least two agents</li> <li>all the agents connect to at least one other agent</li> <li>all the linked agent skills are found in the flow</li> <li>all the linked agent models are found in the flow</li> <li>all the managers have at least one member in the chat group</li> <li>the ordered flow (chats with position &gt;=0) is not empty</li> <li>all agents' code execution config functions exist in the flow skills</li> </ul> <p>Returns:</p> Type Description <code>WaldieFlow</code> <p>The validated flow.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ordered flow is empty. If the model IDs are not unique. If the skill IDs are not unique. If the agents do not connect to any other node. If the manager's group chat has no members.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_flow(self) -&gt; Self:\n    \"\"\"Flow validation.\n\n    - unique node ids\n    - there are at least two agents\n    - all the agents connect to at least one other agent\n    - all the linked agent skills are found in the flow\n    - all the linked agent models are found in the flow\n    - all the managers have at least one member in the chat group\n    - the ordered flow (chats with position &gt;=0) is not empty\n    - all agents' code execution config functions exist in the flow skills\n\n    Returns\n    -------\n    WaldieFlow\n        The validated flow.\n\n    Raises\n    ------\n    ValueError\n        If the ordered flow is empty.\n        If the model IDs are not unique.\n        If the skill IDs are not unique.\n        If the agents do not connect to any other node.\n        If the manager's group chat has no members.\n    \"\"\"\n    if not self.ordered_flow:\n        raise ValueError(\"The ordered flow is empty.\")\n    model_ids = [model.id for model in self.data.models]\n    if len(model_ids) != len(set(model_ids)):\n        raise ValueError(\"Model IDs must be unique.\")\n    skills_ids = [skill.id for skill in self.data.skills]\n    if len(skills_ids) != len(set(skills_ids)):\n        raise ValueError(\"Skill IDs must be unique.\")\n    self.data.agents.validate_flow(model_ids, skills_ids)\n    self._validate_agent_connections()\n    return self\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow_data.WaldieFlowData","title":"<code>WaldieFlowData</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Flow data class.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>List[Dict[str, Any]]</code> <p>The nodes of the flow. We ignore this (UI-related)</p> <code>edges</code> <code>List[Dict[str, Any]]</code> <p>The edges of the flow. We ignore this (UI-related)</p> <code>viewport</code> <code>Dict[str, Any]</code> <p>The viewport of the flow. We ignore this (UI-related)</p> <code>agents</code> <code>WaldieAgents</code> <p>The agents of the flow: users: List[WaldieUserProxy] assistants: List[WaldieAssistant] managers: List[WaldieGroupManager] rag_users : List[WaldieRagUser] See <code>WaldieAgents</code> for more info.</p> <code>models</code> <code>List[WaldieModel]</code> <p>The models of the flow. See <code>WaldieModel</code>.</p> <code>skills</code> <code>List[WaldieSkill]</code> <p>The skills of the flow. See <code>WaldieSkill</code>.</p> <code>chats</code> <code>List[WaldieChat]</code> <p>The chats of the flow. See <code>WaldieChat</code>.</p>"},{"location":"models/model/","title":"Model","text":"<p>Waldie model(llm) model.</p> <p>Waldie Model Data.</p>"},{"location":"models/model/#waldiez.models.model.model.WaldieModel","title":"<code>WaldieModel</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Model class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the model.</p> <code>name</code> <code>str</code> <p>The name of the model.</p> <code>description</code> <code>str</code> <p>The description of the model.</p> <code>tags</code> <code>List[str]</code> <p>The tags of the model.</p> <code>requirements</code> <code>List[str]</code> <p>The requirements of the model.</p> <code>data</code> <code>WaldieModelData</code> <p>The data of the model. See <code>waldie.models.model.WaldieModelData</code> for more information.</p>"},{"location":"models/model/#waldiez.models.model.model.WaldieModel.api_key","title":"<code>api_key: str</code>  <code>property</code>","text":"<p>Get the model's api key.</p>"},{"location":"models/model/#waldiez.models.model.model.WaldieModel.llm_config","title":"<code>llm_config: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get the model's llm config to be used as an autogen argument.</p>"},{"location":"models/model/#waldiez.models.model.model.WaldieModel.price","title":"<code>price: Optional[List[float]]</code>  <code>property</code>","text":"<p>Get the model's price.</p>"},{"location":"models/model/#waldiez.models.model.model_data.WaldieModelData","title":"<code>WaldieModelData</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Model Data.</p> <p>Attributes:</p> Name Type Description <code>base_url</code> <code>Optional[str]</code> <p>The base url of the model, by default None.</p> <code>api_key</code> <code>Optional[str]</code> <p>The api key to use with the model, by default None.</p> <code>api_type</code> <code>Literal['openai', 'azure', 'google', 'anthropic', 'mistral', 'grog', 'together', 'other']</code> <p>The api type of the model.</p> <code>api_version</code> <code>Optional[str]</code> <p>The api version of the model, by default None.</p> <code>temperature</code> <code>Optional[float]</code> <p>The temperature of the model, by default None.</p> <code>top_p</code> <code>Optional[float]</code> <p>The top p of the model, by default None.</p> <code>max_tokens</code> <code>Optional[int]</code> <p>The max tokens of the model, by default None.</p> <code>default_headers</code> <code>Dict[str, str]</code> <p>The default headers of the model.</p> <code>price</code> <code>Optional[WaldieModelPrice]</code> <p>The price of the model, by default None.</p>"},{"location":"models/model/#waldiez.models.model.model_data.WaldieModelPrice","title":"<code>WaldieModelPrice</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Model Price.</p> <p>Attributes:</p> Name Type Description <code>prompt_price_per_1k</code> <code>float</code> <p>The prompt price per 1k tokens.</p> <code>completion_token_price_per_1k</code> <code>float</code> <p>The completion token price per 1k tokens.</p>"},{"location":"models/skill/","title":"Skill","text":"<p>Waldie Skill model.</p> <p>Waldie Skill model.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldieSkill","title":"<code>WaldieSkill</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Skill.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the skill.</p> <code>type</code> <code>Literal['skill']</code> <p>The type of the \"node\" in a graph: \"skill\".</p> <code>name</code> <code>str</code> <p>The name of the skill.</p> <code>description</code> <code>str</code> <p>The description of the skill.</p> <code>tags</code> <code>List[str]</code> <p>The tags of the skill.</p> <code>requirements</code> <code>List[str]</code> <p>The requirements of the skill.</p> <code>data</code> <code>WaldieSkillData</code> <p>The data of the skill. See <code>WaldieSkillData</code>.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldieSkill.content","title":"<code>content: str</code>  <code>property</code>","text":"<p>Get the content (source) of the skill.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldieSkill.secrets","title":"<code>secrets: Dict[str, str]</code>  <code>property</code>","text":"<p>Get the secrets (environment variables) of the skill.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldieSkill.validate_data","title":"<code>validate_data() -&gt; Self</code>","text":"<p>Validate the data.</p> <p>Returns:</p> Type Description <code>WaldieSkill</code> <p>The skill.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the skill name is not in the content. If the skill content is invalid.</p> Source code in <code>waldiez/models/skill/skill.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_data(self) -&gt; Self:\n    \"\"\"Validate the data.\n\n    Returns\n    -------\n    WaldieSkill\n        The skill.\n\n    Raises\n    ------\n    ValueError\n        If the skill name is not in the content.\n        If the skill content is invalid.\n    \"\"\"\n    search = f\"def {self.name}(\"\n    if search not in self.data.content:\n        raise ValueError(\n            f\"The skill name '{self.name}' is not in the content.\"\n        )\n    error, tree = parse_code_string(self.data.content)\n    if error is not None or tree is None:\n        raise ValueError(f\"Invalid skill content: {error}\")\n    return self\n</code></pre>"},{"location":"models/skill/#waldiez.models.skill.skill_data.WaldieSkillData","title":"<code>WaldieSkillData</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Skill Data.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>str</code> <p>The content (source code) of the skill.</p> <code>secrets</code> <code>Dict[str, str]</code> <p>The secrets (environment variables) of the skill.</p>"},{"location":"models/agents/","title":"Agents","text":"<p>Waldie agents model.</p>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldieAgents","title":"<code>WaldieAgents</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie agents model.</p> <p>Attributes:</p> Name Type Description <code>users</code> <code>List[WaldieUserProxy]</code> <p>User proxy agents.</p> <code>assistants</code> <code>List[WaldieAssistant]</code> <p>Assistant agents.</p> <code>managers</code> <code>List[WaldieGroupManager]</code> <p>Group chat mangers.</p> <code>rag_users</code> <code>List[WaldieRagUser]</code> <p>RAG user agents.</p>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldieAgents.members","title":"<code>members: Iterator[WaldieAgent]</code>  <code>property</code>","text":"<p>Get all agents.</p> <p>Yields:</p> Type Description <code>WaldieAgent</code> <p>The agents.</p>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldieAgents.validate_agents","title":"<code>validate_agents() -&gt; Self</code>","text":"<p>Validate the agents.</p> <ul> <li>At least two agents are required.</li> <li>All the agent IDs must be unique.</li> </ul> <p>Returns:</p> Type Description <code>WaldieAgents</code> <p>The agents.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the agents are invalid.</p> Source code in <code>waldiez/models/agents/agents.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_agents(self) -&gt; Self:\n    \"\"\"Validate the agents.\n\n    - At least two agents are required.\n    - All the agent IDs must be unique.\n\n    Returns\n    -------\n    WaldieAgents\n        The agents.\n\n    Raises\n    ------\n    ValueError\n        If the agents are invalid.\n    \"\"\"\n    all_agent_ids = [agent.id for agent in self.members]\n    if len(all_agent_ids) &lt; 2:\n        raise ValueError(\"At least two agents are required.\")\n    if len(all_agent_ids) != len(set(all_agent_ids)):\n        raise ValueError(\"Agent IDs must be unique.\")\n    return self\n</code></pre>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldieAgents.validate_flow","title":"<code>validate_flow(model_ids: List[str], skill_ids: List[str]) -&gt; None</code>","text":"<p>Validate the flow of the agents.</p> <ul> <li>Validate the linked models (the referenced model ids must exist).</li> <li>Validate the linked skills (the referenced skill ids must exist).</li> <li>Validate the code execution (the referenced functions must exist).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model_ids</code> <code>List[str]</code> <p>The list of model IDs.</p> required <code>skill_ids</code> <code>List[str]</code> <p>The list of skill IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the flow is invalid.</p> Source code in <code>waldiez/models/agents/agents.py</code> <pre><code>def validate_flow(self, model_ids: List[str], skill_ids: List[str]) -&gt; None:\n    \"\"\"Validate the flow of the agents.\n\n    - Validate the linked models (the referenced model ids must exist).\n    - Validate the linked skills (the referenced skill ids must exist).\n    - Validate the code execution (the referenced functions must exist).\n\n    Parameters\n    ----------\n    model_ids : List[str]\n        The list of model IDs.\n    skill_ids : List[str]\n        The list of skill IDs.\n\n    Raises\n    ------\n    ValueError\n        If the flow is invalid.\n    \"\"\"\n    all_agent_ids = [agent.id for agent in self.members]\n    for agent in self.members:\n        agent.validate_linked_models(model_ids)\n        agent.validate_linked_skills(skill_ids, agent_ids=all_agent_ids)\n        agent.validate_code_execution(skill_ids=skill_ids)\n        if agent.agent_type == \"manager\" and isinstance(\n            agent, WaldieGroupManager\n        ):\n            agent.validate_transitions(agent_ids=all_agent_ids)\n</code></pre>"},{"location":"models/agents/agent/","title":"Agent","text":"<p>Base agent class to be inherited by all agents.</p> <p>Common data structures for agents.</p> <p>Waldie Agent Code Execution Configuration.</p> <p>Waldie Agent Skill Model.</p> <p>Waldie Agent Nested Chat.</p> <p>Waldie Agent Termination Message Check.</p> <p>Waldie Agent Teachability.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldieAgent","title":"<code>WaldieAgent</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the agent.</p> <code>type</code> <code>Literal['agent']</code> <p>The type of the \"node\" in a graph: \"agent\"</p> <code>agent_type</code> <code>Literal['user', 'assistant', 'manager', 'rag_user']</code> <p>The type of the agent</p> <code>name</code> <code>str</code> <p>The name of the agent.</p> <code>description</code> <code>str</code> <p>The description of the agent.</p> <code>tags</code> <code>List[str]</code> <p>Tags for this agent.</p> <code>requirements</code> <code>List[str]</code> <p>Python requirements for the agent.</p> <code>data</code> <code>WaldieAgentData</code> <p>The data (properties) of this agent. See <code>waldiez.models.agents.WaldieAgentData</code> for more info.</p> <p>Methods:</p> Name Description <code>validate_linked_skills</code> <p>Validate the skills linked to the agent.</p> <code>validate_linked_models</code> <p>Validate the models linked to the agent.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldieAgent.validate_code_execution","title":"<code>validate_code_execution(skill_ids: List[str]) -&gt; None</code>","text":"<p>Validate the code execution config.</p> <p>Parameters:</p> Name Type Description Default <code>skill_ids</code> <code>List[str]</code> <p>The list of skill IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a function is not found</p> Source code in <code>waldiez/models/agents/agent/agent.py</code> <pre><code>def validate_code_execution(self, skill_ids: List[str]) -&gt; None:\n    \"\"\"Validate the code execution config.\n\n    Parameters\n    ----------\n    skill_ids : List[str]\n        The list of skill IDs.\n\n    Raises\n    ------\n    ValueError\n        If a function is not found\n    \"\"\"\n    # if the config dict has functions, make sure they can be found\n    if isinstance(\n        self.data.code_execution_config, WaldieAgentCodeExecutionConfig\n    ):\n        for function in self.data.code_execution_config.functions:\n            if function not in skill_ids:\n                raise ValueError(\n                    f\"Function '{function}' not found in skills\"\n                )\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldieAgent.validate_linked_models","title":"<code>validate_linked_models(model_ids: List[str]) -&gt; None</code>","text":"<p>Validate the models.</p> <p>Parameters:</p> Name Type Description Default <code>model_ids</code> <code>List[str]</code> <p>The list of model IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a model is not found</p> Source code in <code>waldiez/models/agents/agent/agent.py</code> <pre><code>def validate_linked_models(self, model_ids: List[str]) -&gt; None:\n    \"\"\"Validate the models.\n\n    Parameters\n    ----------\n    model_ids : List[str]\n        The list of model IDs.\n\n    Raises\n    ------\n    ValueError\n        If a model is not found\n    \"\"\"\n    # if the config dict has models, make sure they can be found\n    for model in self.data.model_ids:\n        if model not in model_ids:\n            raise ValueError(\n                f\"Model '{model}' not found in agent's {self.id} models\"\n            )\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldieAgent.validate_linked_skills","title":"<code>validate_linked_skills(skill_ids: List[str], agent_ids: List[str]) -&gt; None</code>","text":"<p>Validate the skills.</p> <p>Parameters:</p> Name Type Description Default <code>skill_ids</code> <code>List[str]</code> <p>The list of skill IDs.</p> required <code>agent_ids</code> <code>List[str]</code> <p>The list of agent IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a skill or agent is not found</p> Source code in <code>waldiez/models/agents/agent/agent.py</code> <pre><code>def validate_linked_skills(\n    self, skill_ids: List[str], agent_ids: List[str]\n) -&gt; None:\n    \"\"\"Validate the skills.\n\n    Parameters\n    ----------\n    skill_ids : List[str]\n        The list of skill IDs.\n    agent_ids : List[str]\n        The list of agent IDs.\n\n    Raises\n    ------\n    ValueError\n        If a skill or agent is not found\n    \"\"\"\n    # if the config dict has skills, make sure they can be found\n    for skill in self.data.skills:\n        if skill.id not in skill_ids:\n            raise ValueError(\n                f\"Skill '{skill.id}' not found in agent's {self.id} skills\"\n            )\n        if skill.executor_id not in agent_ids:\n            raise ValueError(\n                f\"Agent '{skill.executor_id}' not found in agents\"\n            )\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent_data.WaldieAgentData","title":"<code>WaldieAgentData</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent Data.</p> <p>Attributes:</p> Name Type Description <code>system_message</code> <code>Optional[str]</code> <p>The agent's system message. Default: None (depends on the agent's type)</p> <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode to use for the agent.</p> <code>code_execution_config</code> <code>Union[WaldieAgentCodeExecutionConfig, False]</code> <p>The code execution config. Either False (no execution) or a dict</p> <code>max_tokens</code> <code>Optional[int]</code> <p>The maximum tokens to use. Default: None (no limit).</p> <code>agent_default_auto_reply</code> <code>Optional[str]</code> <p>The agent's default auto reply when no input is received.</p> <code>max_consecutive_auto_reply</code> <code>Optional[int]</code> <p>The maximum number or consecutive auto replies to use before ending the chat. Default: None (no limit).</p> <code>termination</code> <code>WaldieAgentTerminationMessage</code> <p>The message termination check to use (keyword, method, none)</p> <code>teachability</code> <code>WaldieAgentTeachability</code> <p>The agent teachability configuration.</p> <code>model_ids</code> <code>List[str]</code> <p>A list of models (their ids) to link with the agent.</p> <code>skills</code> <code>List[WaldieAgentLinkedSkill]</code> <p>A list of skills (id and executor) to register.</p> <code>nested_chats</code> <code>List[WaldieAgentNestedChat]</code> <p>A list of nested chats (triggered_by, messages), to register.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.code_execution.WaldieAgentCodeExecutionConfig","title":"<code>WaldieAgentCodeExecutionConfig</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent Code Execution Configuration.</p> <p>Attributes:</p> Name Type Description <code>work_dir</code> <code>Optional[str]</code> <p>The working directory for the code execution.</p> <code>use_docker</code> <code>Optional[bool]</code> <p>Run the code in a docker container.</p> <code>timeout</code> <code>Optional[float]</code> <p>The timeout for the code execution. By default None (no timeout).</p> <code>last_n_messages</code> <code>Optional[int]</code> <p>The chat's last n messages to consider for the code execution.</p> <code>functions</code> <code>Optional[List[str]]</code> <p>If not using docker, a list of function ids to use.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.linked_skill.WaldieAgentLinkedSkill","title":"<code>WaldieAgentLinkedSkill</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent Linked Skill.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the skill to use.</p> <code>executor_id</code> <code>str</code> <p>The id of the agent to use that skill.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.nested_chat.WaldieAgentNestedChat","title":"<code>WaldieAgentNestedChat</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent Nested Chat.</p> <p>Attributes:</p> Name Type Description <code>triggered_by</code> <code>List[WaldieAgentNestedChatMessage]</code> <p>A list of chats (id and is_reply) to determine the triggering of the nested chat.</p> <code>messages</code> <code>List[WaldieAgentNestedChatMessage]</code> <p>The list of messages (chat ids and 'is_reply'z) to include the in the nested chat registration.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.nested_chat.WaldieAgentNestedChatMessage","title":"<code>WaldieAgentNestedChatMessage</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent nested chat message.</p> <p>A reference to a chat's message or reply in a nested chat</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the chat.</p> <code>is_reply</code> <code>bool</code> <p>Whether to use the reply in the chat or not.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.termination_message.WaldieAgentTerminationMessage","title":"<code>WaldieAgentTerminationMessage</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent Termination Message Check.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['none', 'keyword', 'method']</code> <p>The type of the termination check to use: \"none\", \"keyword\", \"method\"</p> <code>keywords</code> <code>List[str]</code> <p>If the type is \"keyword\", the keywords to search in the message.</p> <code>criterion</code> <code>Optional[Literal[\"found\", \"ending\", \"exact\"]] = None</code> <p>If the type is \"keyword\", the criterion to use (e.g.: in, endswith, ==)</p> <code>method_content</code> <code>Optional[str]</code> <p>If the type is \"method\", the code of the method to use. The method must be called <code>is_termination_message</code>, have one argument (<code>message</code>) which is a dict, and return a bool (whether the message is a termination message or not.)</p> <code>string</code> <code>str</code> <p>The value of the termination message.</p> <p>Methods:</p> Name Description <code>validate_termination_message</code> <p>Validate the termination message configuration.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.termination_message.WaldieAgentTerminationMessage.string","title":"<code>string: str</code>  <code>property</code>","text":"<p>Get the value of the termination message.</p> <ul> <li>If the type is \"none\", the value is \"None\".</li> <li>If the type is \"keyword\", the value is a lambda function that checks     if any of the keywords comply with the criterion.</li> <li>If the type is \"method\", the value is the method content.</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>The value of the termination message.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.termination_message.WaldieAgentTerminationMessage.validate_termination_message","title":"<code>validate_termination_message() -&gt; Self</code>","text":"<p>Validate the termination message configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is invalid.</p> <p>Returns:</p> Type Description <code>WaldieAgentTerminationMessage</code> <p>The validated termination message configuration.</p> Source code in <code>waldiez/models/agents/agent/termination_message.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_termination_message(self) -&gt; Self:\n    \"\"\"Validate the termination message configuration.\n\n    Raises\n    ------\n    ValueError\n        If the configuration is invalid.\n    Returns\n    -------\n    WaldieAgentTerminationMessage\n        The validated termination message configuration.\n    \"\"\"\n    if self.type == \"method\":\n        self._validate_method_content()\n    if self.type == \"keyword\":\n        self._validate_keyword()\n    if self.type == \"none\":\n        self._string = \"None\"\n    return self\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.teachability.WaldieAgentTeachability","title":"<code>WaldieAgentTeachability</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Waldie Agent Teachability.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether the teachability is enabled.</p> <code>verbosity</code> <code>Literal[0, 1, 2, 3]</code> <p>The verbosity level of the teachability. Default: 0</p> <code>reset_db</code> <code>bool</code> <p>Whether to reset the database. Default: False</p> <code>recall_threshold</code> <code>float</code> <p>The recall threshold. Default: 1.5</p> <code>max_num_retrievals</code> <code>int</code> <p>The maximum number of retrievals. Default: 10</p>"},{"location":"models/agents/assistant/","title":"Assistant","text":"<p>Assistant agent model.</p> <p>Assistant agent data model.</p>"},{"location":"models/agents/assistant/#waldiez.models.agents.assistant.assistant.WaldieAssistant","title":"<code>WaldieAssistant</code>","text":"<p>               Bases: <code>WaldieAgent</code></p> <p>Assistant agent model.</p> <p>A <code>WaldieAgent</code> with agent_type <code>assistant</code> and default <code>human_input_mode</code>: <code>\"NEVER\"</code> See <code>WaldieAgent</code>, <code>WaldieAssistantData</code>, <code>WaldieAgentData</code> for more info.</p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['assistant']</code> <p>The agent type: 'assistant' for an assistant agent</p> <code>data</code> <code>WaldieAssistantData</code> <p>The assistant agent's data</p>"},{"location":"models/agents/assistant/#waldiez.models.agents.assistant.assistant_data.WaldieAssistantData","title":"<code>WaldieAssistantData</code>","text":"<p>               Bases: <code>WaldieAgentData</code></p> <p>Assistant agent data class.</p> <p>The data for an agent with <code>human_input_mode</code> set to <code>\"ALWAYS\"</code> as default. See the parent's docs (<code>WaldieAgentData</code>) for the rest of the properties.</p> <p>Attributes:</p> Name Type Description <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode, Defaults to <code>NEVER</code></p>"},{"location":"models/agents/group_manager/","title":"GroupManager","text":"<p>Group chat manager agent.</p> <p>Group chat manager data.</p> <p>Group chat speakers.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.group_manager.WaldieGroupManager","title":"<code>WaldieGroupManager</code>","text":"<p>               Bases: <code>WaldieAgent</code></p> <p>Group chat manager agent.</p> <p>A <code>WaldieAgent</code> with agent_type <code>manager</code>, <code>human_input_mode</code>: <code>\"NEVER\"</code> and chat group related config for the agent. Also see <code>WaldieAgent</code>, <code>WaldieGroupManagerData</code>, <code>WaldieAgentData</code></p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['manager']</code> <p>The agent type: 'manager' for a group manager agent</p> <code>data</code> <code>WaldieGroupManagerData</code> <p>The group manager agent's data.</p> <p>Methods:</p> Name Description <code>validate_transitions</code> <p>Validate the transitions.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.group_manager.WaldieGroupManager.validate_transitions","title":"<code>validate_transitions(agent_ids: List[str]) -&gt; None</code>","text":"<p>Validate the transitions.</p> <p>If the selection mode is <code>transition</code>:</p> <ul> <li>if <code>allow_repeat</code> is a list of agent_ids,         make sure these ids exist.</li> <li>make sure the <code>allowed_or_disallowed_transitions</code> mapping         has valid agent ids.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>agent_ids</code> <code>List[str]</code> <p>The list of agent IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the transitions are invalid.</p> Source code in <code>waldiez/models/agents/group_manager/group_manager.py</code> <pre><code>def validate_transitions(self, agent_ids: List[str]) -&gt; None:\n    \"\"\"Validate the transitions.\n\n    If the selection mode is `transition`:\n\n    - if `allow_repeat` is a list of agent_ids,\n            make sure these ids exist.\n    - make sure the `allowed_or_disallowed_transitions` mapping\n            has valid agent ids.\n\n    Parameters\n    ----------\n    agent_ids : List[str]\n        The list of agent IDs.\n\n    Raises\n    ------\n    ValueError\n        If the transitions are invalid.\n    \"\"\"\n    speakers: WaldieGroupManagerSpeakers = self.data.speakers\n    if speakers.selection_mode != \"transition\":\n        return\n    allow_repeat = speakers.allow_repeat\n    if isinstance(allow_repeat, list):\n        for agent_id in allow_repeat:\n            if agent_id not in agent_ids:\n                raise ValueError(f\"Invalid agent id: {agent_id}\")\n    for (\n        agent_id,\n        transitions,\n    ) in speakers.allowed_or_disallowed_transitions.items():\n        if agent_id not in agent_ids:\n            raise ValueError(f\"Invalid agent id: {agent_id}\")\n        for agent_id in transitions:\n            if agent_id not in agent_ids:\n                raise ValueError(f\"Invalid agent id: {agent_id}\")\n</code></pre>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.group_manager_data.WaldieGroupManagerData","title":"<code>WaldieGroupManagerData</code>","text":"<p>               Bases: <code>WaldieAgentData</code></p> <p>Group chat manager data class.</p> <p>The data for an agent with <code>human_input_mode</code> set to \"NEVER\" as default. and the chat group's related extra properties. See the parent's docs (<code>WaldieAgentData</code>) for the rest of the properties.</p> <p>Attributes:</p> Name Type Description <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode, Defaults to <code>NEVER</code></p> <code>max_round</code> <code>Optional[int]</code> <p>The maximum number of rounds to have in the group.</p> <code>admin_name</code> <code>Optional[str]</code> <p>The name of the group's admin. Make sure you use a name of an agent in the group.</p> <code>speakers</code> <code>WaldieGroupManagerSpeakers</code> <p>The rules for the speaker selection and repetition</p> <code>enable_clear_history</code> <code>Optional[bool]</code> <p>Enable clearing the history in the chat group.</p> <code>send_introductions</code> <code>bool</code> <p>Send the group members' introductions.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.speakers.WaldieGroupManagerSpeakers","title":"<code>WaldieGroupManagerSpeakers</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>Group chat speakers.</p> <p>If the method for the speaker selection is <code>custom</code> the <code>selection_custom_method</code> contents (source code) will be used. The method must be called <code>custom_speaker_selection</code>, have two arguments:</p> <ul> <li>last_speaker: <code>autogen.ConversableAgent</code></li> <li>groupchat: <code>autogen.GroupChat</code></li> </ul> <p>and return a <code>Union[Agent, str, None]</code></p> Example <pre><code>{\n    \"selectionMethod\": \"custom\",\n    \"selectionCustomMethod\": (\n        \"def custom_speaker_selection(last_speaker, groupchat):\\n\"\n        \"    return last_speaker\"\n    ),\n    ...\n}\n</code></pre> <p>Attributes:</p> Name Type Description <code>selection_method</code> <code>WaldieGroupManagerSpeakersSelectionMethod</code> <p>The next speaker selection method.</p> <code>selection_custom_method</code> <code>Optional[str]</code> <p>Method for custom selection.</p> <code>max_retries_for_selecting</code> <code>Optional[int]</code> <p>Max retries for selecting a speaker.</p> <code>selection_mode</code> <code>WaldieGroupManagerSpeakersSelectionMode</code> <p>Selection mode.</p> <code>allow_repeat</code> <code>Union[bool, List[str]]</code> <p>Allow repeat.</p> <code>allowed_or_disallowed_transitions</code> <code>Dict[str, List[str]]</code> <p>Allowed or disallowed transitions.</p> <code>transitions_type</code> <code>WaldieGroupManagerSpeakersTransitionsType</code> <p>The type of transition rules to use if if a mapping (agent =&gt; List[agents]) is used: <code>allowed</code> (default) or <code>disallowed</code></p> <code>custom_method_string</code> <code>Optional[str]</code> <p>The custom method string.</p> <p>Methods:</p> Name Description <code>validate_group_speakers_config</code> <p>Validate the speakers config.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.speakers.WaldieGroupManagerSpeakers.custom_method_string","title":"<code>custom_method_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the custom method string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The custom method string.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.speakers.WaldieGroupManagerSpeakers.validate_group_speakers_config","title":"<code>validate_group_speakers_config() -&gt; Self</code>","text":"<p>Validate the speakers config.</p> <p>Returns:</p> Type Description <code>GroupManagerSpeakers</code> <p>The group manager speakers config.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the custom method is invalid.</p> Source code in <code>waldiez/models/agents/group_manager/speakers.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_group_speakers_config(self) -&gt; Self:\n    \"\"\"Validate the speakers config.\n\n    Returns\n    -------\n    GroupManagerSpeakers\n        The group manager speakers config.\n\n    Raises\n    ------\n    ValueError\n        If the custom method is invalid.\n    \"\"\"\n    if self.selection_method == \"custom\":\n        if not self.selection_custom_method:\n            raise ValueError(\"No custom method provided.\")\n        function_name: WaldieMethodName = \"custom_speaker_selection\"\n        is_valid, error_or_body = check_function(\n            self.selection_custom_method, function_name=function_name\n        )\n        if not is_valid or not error_or_body:\n            # pylint: disable=inconsistent-quotes\n            raise ValueError(\n                f\"Invalid custom method: {error_or_body or 'no content'}\"\n            )\n        self._custom_method_string = error_or_body\n    return self\n</code></pre>"},{"location":"models/agents/rag_user/","title":"RagUser","text":"<p>RAG user agent. It extends a user agent and has RAG related parameters (<code>retrieve_config</code>).</p> <p>Waldie RAG user agent data.</p> <p>RAG user agent retrieve config.</p> <p>The vector db config for the RAG user agent.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.rag_user.WaldieRagUser","title":"<code>WaldieRagUser</code>","text":"<p>               Bases: <code>WaldieAgent</code></p> <p>RAG user agent.</p> <p>It extends a user agent and has RAG related parameters.</p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['rag_user']</code> <p>The agent type: 'rag_user' for a RAG user agent.</p> <code>data</code> <code>WaldieRagUserData</code> <p>The RAG user agent's data. See <code>WaldieRagUserData</code> for more info.</p> <code>retrieve_config</code> <code>WaldieRagUserRetrieveConfig</code> <p>The RAG user agent's retrieve config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.rag_user.WaldieRagUser.retrieve_config","title":"<code>retrieve_config: WaldieRagUserRetrieveConfig</code>  <code>property</code>","text":"<p>Get the retrieve config.</p> <p>Returns:</p> Type Description <code>WaldieRagUserRetrieveConfig</code> <p>The RAG user agent's retrieve config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.rag_user_data.WaldieRagUserData","title":"<code>WaldieRagUserData</code>","text":"<p>               Bases: <code>WaldieUserProxyData</code></p> <p>RAG user agent data.</p> <p>The data for a RAG user agent.</p> <p>Attributes:</p> Name Type Description <code>retrieve_config</code> <code>WaldieRagUserRetrieveConfig</code> <p>The RAG user agent's retrieve config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig","title":"<code>WaldieRagUserRetrieveConfig</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>RAG user agent.</p> <p>Attributes:</p> Name Type Description <code>task</code> <code>Literal['code', 'qa', 'default']</code> <p>The task of the retrieve chat. Possible values are 'code', 'qa' and 'default'. System prompt will be different for different tasks. The default value is default, which supports both code and qa, and provides source information in the end of the response.</p> <code>vector_db</code> <code>Literal['chroma', 'pgvector', 'mongodb', 'qdrant']</code> <p>The vector db for the retrieve chat.</p> <code>db_config</code> <code>Annotated[WaldieVectorDbConfig, Field]</code> <p>The config for the selected vector db.</p> <code>docs_path</code> <code>Optional[Union[str, List[str]]]</code> <p>The path to the docs directory. It can also be the path to a single file, the url to a single file or a list of directories, files and urls. Default is None, which works only if the collection is already created.</p> <code>new_docs</code> <code>bool</code> <p>When True, only adds new documents to the collection; when False, updates existing documents and adds new ones. Default is True. Document id is used to determine if a document is new or existing. By default, the id is the hash value of the content.</p> <code>model</code> <code>Optional[str]</code> <p>The model to use for the retrieve chat. If key not provided, a default model gpt-4 will be used.</p> <code>chunk_token_size</code> <code>Optional[int]</code> <p>The chunk token size for the retrieve chat. If key not provided, a default size max_tokens * 0.4 will be used.</p> <code>context_max_tokens</code> <code>Optional[int]</code> <p>The context max token size for the retrieve chat. If key not provided, a default size max_tokens * 0.8 will be used.</p> <code>chunk_mode</code> <code>Optional[str]</code> <p>The chunk mode for the retrieve chat. Possible values are 'multi_lines' and 'one_line'. If key not provided, a default mode multi_lines will be used.</p> <code>must_break_at_empty_line</code> <code>bool</code> <p>Chunk will only break at empty line if True. Default is True. If chunk_mode is 'one_line', this parameter will be ignored.</p> <code>use_custom_embedding</code> <code>bool</code> <p>Whether to use custom embedding for the retrieve chat. Default is False. If True, the embedding_function should be provided.</p> <code>embedding_function</code> <code>Optional[str]</code> <p>The embedding function for creating the vector db. Default is None, SentenceTransformer with the given embedding_model will be used. If you want to use OpenAI, Cohere, HuggingFace or other embedding functions, you can pass it here, follow the examples in https://docs.trychroma.com/guides/embeddings.</p> <code>customized_prompt</code> <code>Optional[str]</code> <p>The customized prompt for the retrieve chat. Default is None.</p> <code>customized_answer_prefix</code> <code>Optional[str]</code> <p>The customized answer prefix for the retrieve chat. Default is ''. If not '' and the customized_answer_prefix is not in the answer, Update Context will be triggered.</p> <code>update_context</code> <code>bool</code> <p>If False, will not apply Update Context for interactive retrieval. Default is True.</p> <code>collection_name</code> <code>Optional[str]</code> <p>The name of the collection. If key not provided, a default name autogen-docs will be used.</p> <code>get_or_create</code> <code>bool</code> <p>Whether to get the collection if it exists. Default is False.</p> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the collection if it exists. Default is False. Case 1. if the collection does not exist, create the collection. Case 2. the collection exists, if overwrite is True, it will overwrite the collection. Case 3. the collection exists and overwrite is False, if get_or_create is True, it will get the collection, otherwise it raise a ValueError.</p> <code>use_custom_token_count</code> <code>bool</code> <p>Whether to use custom token count function for the retrieve chat. Default is False. If True, the custom_token_count_function should be provided.</p> <code>custom_token_count_function</code> <code>Optional[str]</code> <p>A custom function to count the number of tokens in a string. The function should take (text:str, model:str) as input and return the token_count(int). the retrieve_config['model'] will be passed in the function. Default is autogen.token_count_utils.count_token that uses tiktoken, which may not be accurate for non-OpenAI models.</p> <code>use_custom_text_split</code> <code>bool</code> <p>Whether to use custom text split function for the retrieve chat. Default is False. If True, the custom_text_split_function should be provided.</p> <code>custom_text_split_function</code> <code>Optional[str]</code> <p>A custom function to split a string into a list of strings. Default is None, will use the default function in autogen.retrieve_utils. split_text_to_chunks.</p> <code>custom_text_types</code> <code>Optional[List[str]]</code> <p>A list of file types to be processed. Default is autogen.retrieve_utils. TEXT_FORMATS. This only applies to files under the directories in docs_path. Explicitly included files and urls will be chunked regardless of their types.</p> <code>recursive</code> <code>bool</code> <p>Whether to search documents recursively in the docs_path. Default is True.</p> <code>distance_threshold</code> <code>float</code> <p>The threshold for the distance score, only distance smaller than it will be returned. Will be ignored if &lt; 0. Default is -1.</p> <code>embedding_function_string</code> <code>Optional[str]</code> <p>The embedding function string (if use_custom_embedding is True).</p> <code>token_count_function_string</code> <code>Optional[str]</code> <p>The token count function string (if use_custom_token_count is True).</p> <code>text_split_function_string</code> <code>Optional[str]</code> <p>The text split function string (if use_custom_text_split is True).</p> <p>Methods:</p> Name Description <code>validate_custom_embedding_function</code> <p>Validate the custom embedding function.</p> <code>validate_custom_token_count_function</code> <p>Validate the custom token count function.</p> <code>validate_custom_text_split_function</code> <p>Validate the custom text split function.</p> <code>validate_rag_user_data</code> <p>Validate the RAG user data.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig.embedding_function_string","title":"<code>embedding_function_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the embedding function string.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The embedding function string.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig.text_split_function_string","title":"<code>text_split_function_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the text split function string.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The text split function string.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig.token_count_function_string","title":"<code>token_count_function_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the token count function string.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The token count function string.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig.validate_custom_embedding_function","title":"<code>validate_custom_embedding_function() -&gt; None</code>","text":"<p>Validate the custom embedding function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def validate_custom_embedding_function(self) -&gt; None:\n    \"\"\"Validate the custom embedding function.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_custom_embedding:\n        if not self.embedding_function:\n            raise ValueError(\n                \"The embedding_function is required \"\n                \"if use_custom_embedding is True.\"\n            )\n        function_name: WaldieMethodName = \"custom_embedding_function\"\n        valid, error_or_content = check_function(\n            self.embedding_function, function_name\n        )\n        if not valid:\n            raise ValueError(error_or_content)\n        self._embedding_function_string = error_or_content\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig.validate_custom_text_split_function","title":"<code>validate_custom_text_split_function() -&gt; None</code>","text":"<p>Validate the custom text split function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def validate_custom_text_split_function(self) -&gt; None:\n    \"\"\"Validate the custom text split function.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_custom_text_split:\n        if not self.custom_text_split_function:\n            raise ValueError(\n                \"The custom_text_split_function is required \"\n                \"if use_custom_text_split is True.\"\n            )\n        function_name: WaldieMethodName = \"custom_text_split_function\"\n        valid, error_or_content = check_function(\n            self.custom_text_split_function, function_name\n        )\n        if not valid:\n            raise ValueError(error_or_content)\n        self._text_split_function_string = error_or_content\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig.validate_custom_token_count_function","title":"<code>validate_custom_token_count_function() -&gt; None</code>","text":"<p>Validate the custom token count function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def validate_custom_token_count_function(self) -&gt; None:\n    \"\"\"Validate the custom token count function.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_custom_token_count:\n        if not self.custom_token_count_function:\n            raise ValueError(\n                \"The custom_token_count_function is required \"\n                \"if use_custom_token_count is True.\"\n            )\n        function_name: WaldieMethodName = \"custom_token_count_function\"\n        valid, error_or_content = check_function(\n            self.custom_token_count_function, function_name\n        )\n        if not valid:\n            raise ValueError(error_or_content)\n        self._token_count_function_string = error_or_content\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldieRagUserRetrieveConfig.validate_rag_user_data","title":"<code>validate_rag_user_data() -&gt; Self</code>","text":"<p>Validate the RAG user data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> <p>Returns:</p> Type Description <code>WaldieRagUserData</code> <p>The validated RAG user data.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_rag_user_data(self) -&gt; Self:\n    \"\"\"Validate the RAG user data.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n\n    Returns\n    -------\n    WaldieRagUserData\n        The validated RAG user data.\n    \"\"\"\n    self.validate_custom_embedding_function()\n    self.validate_custom_token_count_function()\n    self.validate_custom_text_split_function()\n    if not self.db_config.model:\n        self.db_config.model = WaldieRagUserModels[self.vector_db]\n    return self\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.vector_db_config.WaldieRagUserVectorDbConfig","title":"<code>WaldieRagUserVectorDbConfig</code>","text":"<p>               Bases: <code>WaldieBase</code></p> <p>The config for the vector db.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The model to use for the vector db embeddings.</p> <code>use_memory</code> <code>bool</code> <p>Whether to use memory for the vector db (if <code>qdrant</code> is used).</p> <code>use_local_storage</code> <code>bool</code> <p>Whether to use local storage for the db (if <code>qdrant</code> or <code>chroma</code> is used).</p> <code>local_storage_path</code> <code>Optional[str]</code> <p>The path to the local storage for the vector db (if <code>qdrant</code> or <code>chroma</code> is used).</p> <code>connection_url</code> <code>Optional[str]</code> <p>The connection url for the vector db.</p> <code>wait_until_index_ready</code> <code>Optional[float]</code> <p>Blocking call to wait until the database indexes are ready (if <code>mongodb</code> is used). None, the default, means no wait.</p> <code>wait_until_document_ready</code> <code>Optional[float]</code> <p>Blocking call to wait until the database documents are ready (if <code>mongodb</code> is used). None, the default, means no wait.</p> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>The metadata to use for the vector db. Example: {\"hnsw:space\": \"ip\", \"hnsw:construction_ef\": 30, \"hnsw:M\": 32}</p> <p>Methods:</p> Name Description <code>validate_vector_db_config</code> <p>Validate the vector db config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.vector_db_config.WaldieRagUserVectorDbConfig.validate_vector_db_config","title":"<code>validate_vector_db_config() -&gt; Self</code>","text":"<p>Validate the vector db config.</p> <p>if local storage is used, make sure the path is provided, and make it absolute if not already.</p> <p>Returns:</p> Type Description <code>WaldieRagUserVectorDbConfig</code> <p>The vector db config.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/vector_db_config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_vector_db_config(self) -&gt; Self:\n    \"\"\"Validate the vector db config.\n\n    if local storage is used, make sure the path is provided,\n    and make it absolute if not already.\n\n    Returns\n    -------\n    WaldieRagUserVectorDbConfig\n        The vector db config.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_local_storage:\n        if self.local_storage_path is None:\n            raise ValueError(\n                \"The local storage path must be provided if local storage is used.\"\n            )\n        as_path = Path(self.local_storage_path)\n        if not as_path.is_absolute():\n            self.local_storage_path = str(as_path.resolve())\n    return self\n</code></pre>"},{"location":"models/agents/user_proxy/","title":"UserProxy","text":"<p>User proxy agent model.</p> <p>User proxy agent data module.</p>"},{"location":"models/agents/user_proxy/#waldiez.models.agents.user_proxy.user_proxy.WaldieUserProxy","title":"<code>WaldieUserProxy</code>","text":"<p>               Bases: <code>WaldieAgent</code></p> <p>User proxy agent model.</p> <p>A <code>WaldieAgent</code> with agent_type <code>user</code> and default <code>human_input_mode</code>: <code>\"ALWAYS\"</code> See <code>WaldieAgent</code>, <code>WaldieUserProxyData</code>, <code>WaldieAgentData</code> for more info.</p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['user']</code> <p>The agent type: 'user' for a user proxy agent</p> <code>data</code> <code>WaldieUserProxyData</code> <p>The user proxy agent's data</p>"},{"location":"models/agents/user_proxy/#waldiez.models.agents.user_proxy.user_proxy_data.WaldieUserProxyData","title":"<code>WaldieUserProxyData</code>","text":"<p>               Bases: <code>WaldieAgentData</code></p> <p>User proxy agent data class.</p> <p>The data for an agent with <code>human_input_mode</code> set to <code>\"ALWAYS\"</code> as default. See the parent's docs (<code>WaldieAgentData</code>) for the rest of the properties.</p> <p>Attributes:</p> Name Type Description <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode, Defaults to <code>ALWAYS</code></p>"},{"location":"stream/consumer/","title":"Consumer","text":"<p>TCP socket input consumer.</p> <p>It connects to a TCP server, listens for <code>INPUT:</code> messages to get the user's input, and sends <code>REQUEST:</code> messages to prompt the user,</p>"},{"location":"stream/consumer/#waldiez.stream.consumer.TCPConsumer","title":"<code>TCPConsumer(host: str, port: int, timeout: Optional[float] = None)</code>","text":"<p>TCP socket input consumer.</p> <p>Create a new input consumer.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to connect to.</p> required <code>port</code> <code>int</code> <p>The port to connect to.</p> required <code>timeout</code> <code>float</code> <p>The timeout for the consumer, by default None (no timeout).</p> <code>None</code> Source code in <code>waldiez/stream/consumer.py</code> <pre><code>def __init__(\n    self, host: str, port: int, timeout: Optional[float] = None\n) -&gt; None:\n    \"\"\"Create a new input consumer.\n\n    Parameters\n    ----------\n    host : str\n        The host to connect to.\n    port : int\n        The port to connect to.\n    timeout : float, optional\n        The timeout for the consumer, by default None (no timeout).\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.timeout = timeout\n    self._running = False\n    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n</code></pre>"},{"location":"stream/consumer/#waldiez.stream.consumer.TCPConsumer.get_response","title":"<code>get_response() -&gt; Optional[str]</code>","text":"<p>Get the response.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The response if available, None otherwise.</p> Source code in <code>waldiez/stream/consumer.py</code> <pre><code>def get_response(self) -&gt; Optional[str]:\n    \"\"\"Get the response.\n\n    Returns\n    -------\n    Optional[str]\n        The response if available, None otherwise.\n    \"\"\"\n    if not self._running:\n        self.start()\n    if self.timeout is None or self.timeout &lt; 1:\n        return self._get_response_no_timeout()\n    return self._get_response_with_timeout(self.timeout)\n</code></pre>"},{"location":"stream/consumer/#waldiez.stream.consumer.TCPConsumer.is_running","title":"<code>is_running() -&gt; bool</code>","text":"<p>Check if the consumer is running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True is the consumer is running, else False</p> Source code in <code>waldiez/stream/consumer.py</code> <pre><code>def is_running(self) -&gt; bool:\n    \"\"\"Check if the consumer is running.\n\n    Returns\n    -------\n    bool\n        True is the consumer is running, else False\n    \"\"\"\n    return self._running\n</code></pre>"},{"location":"stream/consumer/#waldiez.stream.consumer.TCPConsumer.send_prompt","title":"<code>send_prompt(prompt: str) -&gt; None</code>","text":"<p>Send a prompt.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send.</p> required Source code in <code>waldiez/stream/consumer.py</code> <pre><code>def send_prompt(self, prompt: str) -&gt; None:\n    \"\"\"Send a prompt.\n\n    Parameters\n    ----------\n    prompt : str\n        The prompt to send.\n    \"\"\"\n    if not self._running:\n        self.start()\n    message = f\"REQUEST:{prompt}\" + \"\\r\\n\"\n    self.socket.sendall(message.encode(\"utf-8\"))\n</code></pre>"},{"location":"stream/consumer/#waldiez.stream.consumer.TCPConsumer.start","title":"<code>start() -&gt; None</code>","text":"<p>Start the consumer.</p> Source code in <code>waldiez/stream/consumer.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the consumer.\"\"\"\n    if self._running:\n        return\n    self._running = True\n    self.socket.connect((self.host, self.port))\n    self.socket.sendall(\"CONSUMER\\r\\n\".encode(\"utf-8\"))\n</code></pre>"},{"location":"stream/consumer/#waldiez.stream.consumer.TCPConsumer.stop","title":"<code>stop() -&gt; None</code>","text":"<p>Close the consumer.</p> Source code in <code>waldiez/stream/consumer.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Close the consumer.\"\"\"\n    try:\n        self.socket.close()\n    except OSError:\n        pass\n    del self.socket\n    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n    self._running = False\n</code></pre>"},{"location":"stream/provider/","title":"Provider","text":"<p>TCP socket input provider.</p> <p>It connects to a TCP server, listens for <code>PROVIDE:</code> messages to receive prompts, and sends <code>USE:</code> messages to pass the response.</p>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderThread","title":"<code>InputProviderThread(host: str, port: int, response: Optional[str], timeout: Optional[float] = None)</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Input provider thread.</p> <p>Create a new input provider thread.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to connect to.</p> required <code>port</code> <code>int</code> <p>The port to connect to.</p> required <code>response</code> <code>str</code> <p>The response to send.</p> required <code>timeout</code> <code>float</code> <p>The timeout for the provider, by default None (no timeout).</p> <code>None</code> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n    response: Optional[str],\n    timeout: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Create a new input provider thread.\n\n    Parameters\n    ----------\n    host : str\n        The host to connect to.\n    port : int\n        The port to connect to.\n    response : str, optional\n        The response to send.\n    timeout : float, optional\n        The timeout for the provider, by default None (no timeout).\n    \"\"\"\n    super().__init__(\n        name=\"InputProviderThread\",\n        daemon=True,\n        target=self.run,\n    )\n    self.host = host\n    self.port = port\n    self.timeout = timeout\n    self._response = response\n    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n    self.running = False\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderThread.response","title":"<code>response: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>Get the response.</p>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderThread.run","title":"<code>run() -&gt; None</code>","text":"<p>Run the provider.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the provider.\"\"\"\n    if self.timeout is None or self.timeout &lt; 1:\n        self._run_no_timeout()\n    else:\n        self._run_with_timeout(self.timeout)\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderWrapper","title":"<code>InputProviderWrapper(host: str, port: int, response: Optional[str] = None, timeout: Optional[float] = None)</code>","text":"<p>Input provider wrapper.</p> <p>Create a new input provider wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to connect to.</p> required <code>port</code> <code>int</code> <p>The port to connect to.</p> required <code>response</code> <code>str</code> <p>The response to send.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The timeout for the provider, by default None (no timeout).</p> <code>None</code> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n    response: Optional[str] = None,\n    timeout: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Create a new input provider wrapper.\n\n    Parameters\n    ----------\n    host : str\n        The host to connect to.\n    port : int\n        The port to connect to.\n    response : str, optional\n        The response to send.\n    timeout : float, optional\n        The timeout for the provider, by default None (no timeout).\n    \"\"\"\n    self._host = host\n    self._port = port\n    self._timeout = timeout\n    self._response = response\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderWrapper.response","title":"<code>response: Optional[str]</code>  <code>property</code>","text":"<p>Get the response.</p>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderWrapper.set_response","title":"<code>set_response(response: str) -&gt; None</code>","text":"<p>Set the response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>The response to set.</p> required Source code in <code>waldiez/stream/provider.py</code> <pre><code>def set_response(self, response: str) -&gt; None:\n    \"\"\"Set the response.\n\n    Parameters\n    ----------\n    response : str\n        The response to set.\n    \"\"\"\n    self._response = response\n    if self.thread:\n        self.thread.response = response\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderWrapper.start","title":"<code>start() -&gt; None</code>","text":"<p>Start the provider.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the provider.\"\"\"\n    self.thread = InputProviderThread(\n        self._host, self._port, self._response, self._timeout\n    )\n    self.thread.daemon = True\n    self.thread.start()\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.InputProviderWrapper.stop","title":"<code>stop() -&gt; None</code>","text":"<p>Stop the provider.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the provider.\"\"\"\n    if self.thread:\n        self.thread.running = False\n        self.thread.join(timeout=1)\n        del self.thread\n        self.thread = None\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider","title":"<code>TCPProvider(host: str, port: int, response: Optional[str] = None, timeout: Optional[float] = 30)</code>","text":"<p>Input provider.</p> <p>Create a new input provider.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to connect to.</p> required <code>port</code> <code>int</code> <p>The port to connect to.</p> required <code>response</code> <code>str</code> <p>The response to send.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The timeout for the provider, by default 30.</p> <code>30</code> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n    response: Optional[str] = None,\n    timeout: Optional[float] = 30,\n) -&gt; None:\n    \"\"\"Create a new input provider.\n\n    Parameters\n    ----------\n    host : str\n        The host to connect to.\n    port : int\n        The port to connect to.\n    response : str, optional\n        The response to send.\n    timeout : float, optional\n        The timeout for the provider, by default 30.\n    \"\"\"\n    self._host = host\n    self._port = port\n    self._response = response\n    self._timeout = timeout\n    self._start_called = False\n    self._init_wrapper()\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.is_running","title":"<code>is_running() -&gt; bool</code>","text":"<p>Check if the provider is running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the provider is running, False otherwise.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def is_running(self) -&gt; bool:\n    \"\"\"Check if the provider is running.\n\n    Returns\n    -------\n    bool\n        True if the provider is running, False otherwise.\n    \"\"\"\n    if not self._wrapper:\n        return False\n    if not self.thread:\n        return False\n    return self.thread.running is True\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.response","title":"<code>response: Optional[str]</code>  <code>property</code>","text":"<p>Get the response.</p>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.restart","title":"<code>restart() -&gt; None</code>","text":"<p>Restart the provider.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def restart(self) -&gt; None:\n    \"\"\"Restart the provider.\"\"\"\n    self.stop()\n    self.start()\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.set_response","title":"<code>set_response(response: str) -&gt; None</code>","text":"<p>Set the response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>The response to set.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the wrapper is not initialized.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def set_response(self, response: str) -&gt; None:\n    \"\"\"Set the response.\n\n    Parameters\n    ----------\n    response : str\n        The response to set.\n\n    Raises\n    ------\n    RuntimeError\n        If the wrapper is not initialized.\n    \"\"\"\n    if not self._wrapper:\n        raise RuntimeError(\"Wrapper not initialized\")\n    self._wrapper.set_response(response or \"\\n\")\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.start","title":"<code>start() -&gt; None</code>","text":"<p>Start the provider.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the wrapper is not initialized.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the provider.\n\n    Raises\n    ------\n    RuntimeError\n        If the wrapper is not initialized.\n    \"\"\"\n    # avoid starting the provider multiple times\n    # (if the wrapped thread has not yet started)\n    if self._start_called is True:\n        return\n    self._start_called = True\n    if self.is_running():\n        return\n    if not self._wrapper:\n        raise RuntimeError(\"Wrapper not initialized\")\n    self._wrapper.start()\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.stop","title":"<code>stop() -&gt; None</code>","text":"<p>Stop the provider.</p> Source code in <code>waldiez/stream/provider.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the provider.\"\"\"\n    self._start_called = False\n    if not self.is_running():\n        return\n    if self._wrapper:\n        self._wrapper.stop()\n    del self._wrapper\n    self._init_wrapper()\n</code></pre>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.thread","title":"<code>thread: Optional[InputProviderThread]</code>  <code>property</code>","text":"<p>Get the thread.</p>"},{"location":"stream/provider/#waldiez.stream.provider.TCPProvider.wait","title":"<code>wait(timeout: float) -&gt; None</code>","text":"<p>Wait until the provider is running.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>The timeout to wait.</p> required Source code in <code>waldiez/stream/provider.py</code> <pre><code>def wait(self, timeout: float) -&gt; None:\n    \"\"\"Wait until the provider is running.\n\n    Parameters\n    ----------\n    timeout : float\n        The timeout to wait.\n    \"\"\"\n    start_time = time.time()\n    while not self.is_running():\n        if time.time() - start_time &gt; timeout:\n            break\n        time.sleep(1)\n</code></pre>"},{"location":"stream/server/","title":"Server","text":"<p>Simple TCP server using twisted.</p> <p>It listens for connections from an input provider and an input consumer, and forwards messages between them.</p>"},{"location":"stream/server/#waldiez.stream.server.ServerFactory","title":"<code>ServerFactory()</code>","text":"<p>               Bases: <code>Factory</code></p> <p>Server factory.</p> <p>Initialize the factory.</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the factory.\"\"\"\n    super().__init__()\n    self.clients = {\n        \"provider\": None,\n        \"consumer\": None,\n    }\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerFactory.buildProtocol","title":"<code>buildProtocol(addr: str) -&gt; ServerProtocol</code>","text":"<p>Build the protocol.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>The address (ignored)</p> required <p>Returns:</p> Type Description <code>ServerProtocol</code> <p>The factory's protocol.</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def buildProtocol(self, addr: str) -&gt; \"ServerProtocol\":\n    \"\"\"Build the protocol.\n\n    Parameters\n    ----------\n    addr : str\n        The address (ignored)\n\n    Returns\n    -------\n    ServerProtocol\n        The factory's protocol.\n    \"\"\"\n    self.protocol = ServerProtocol()\n    self.protocol.set_factory(self)\n    return self.protocol\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerProtocol","title":"<code>ServerProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Server protocol.</p>"},{"location":"stream/server/#waldiez.stream.server.ServerProtocol.connectionLost","title":"<code>connectionLost(reason: Failure = connectionDone) -&gt; None</code>","text":"<p>Handle connection lost event.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Failure</code> <p>The reason for the connection loss, by default connectionDone</p> <code>connectionDone</code> Source code in <code>waldiez/stream/server.py</code> <pre><code>def connectionLost(self, reason: Failure = connectionDone) -&gt; None:\n    \"\"\"Handle connection lost event.\n\n    Parameters\n    ----------\n    reason : Failure, optional\n        The reason for the connection loss, by default connectionDone\n    \"\"\"\n    if self.factory.clients[\"provider\"] == self:\n        self.factory.clients[\"provider\"] = None\n        LOGGER.info(\"Input provider disconnected.\")\n    elif self.factory.clients[\"consumer\"] == self:\n        self.factory.clients[\"consumer\"] = None\n        LOGGER.info(\"Input consumer disconnected.\")\n    super().connectionLost(reason)\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerProtocol.dataReceived","title":"<code>dataReceived(data: bytes) -&gt; None</code>","text":"<p>Handle a data received event.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data received.</p> required Source code in <code>waldiez/stream/server.py</code> <pre><code>def dataReceived(self, data: bytes) -&gt; None:\n    \"\"\"Handle a data received event.\n\n    Parameters\n    ----------\n    data : bytes\n        The data received.\n    \"\"\"\n    # we might get multiple messages in one chunk\n    # i.e. CONSUMER\\r\\nREQUEST:prompt\\r\\n\n    message = data.decode(\"utf-8\")\n    if message in (\"PROVIDER\\r\\n\", \"PROVIDER\\n\", \"PROVIDER\"):\n        LOGGER.debug(\"Input provider connected.\")\n        self.factory.clients[\"provider\"] = self\n        return\n    if message.startswith(\"CONSUMER\\r\\n\"):\n        LOGGER.debug(\"Input consumer connected.\")\n        self.factory.clients[\"consumer\"] = self\n        rest = message[len(\"CONSUMER\\r\\n\") :]\n        if rest:\n            self.message_received(rest)\n        return\n    self.message_received(message)\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerProtocol.message_received","title":"<code>message_received(message: str) -&gt; None</code>","text":"<p>Handle a message received event.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message received.</p> required Source code in <code>waldiez/stream/server.py</code> <pre><code>def message_received(self, message: str) -&gt; None:\n    \"\"\"Handle a message received event.\n\n    Parameters\n    ----------\n    message : str\n        The message received.\n    \"\"\"\n    if message.startswith(\"REQUEST:\"):\n        prompt = message[len(\"REQUEST:\") :]\n        if prompt.endswith(\"\\r\\n\"):\n            prompt = prompt[: -(len(\"\\r\\n\"))]\n        prompt = prompt.strip()\n        LOGGER.debug(\"Received request: %s\", prompt)\n        if self.factory.clients[\"provider\"]:\n            msg = f\"PROVIDE:{prompt}\" + \"\\r\\n\"\n            transport = self.factory.clients[\"provider\"].transport\n            transport.write(msg.encode(\"utf-8\"))  # type: ignore\n        else:\n            LOGGER.error(\"No provider connected.\")\n    elif message.startswith(\"USE:\"):\n        response = message[len(\"USE:\") :]\n        if response.endswith(\"\\r\\n\"):\n            response = response[: -(len(\"\\r\\n\"))]\n        response = response.strip()\n        LOGGER.debug(\"Received response: %s\", response)\n        if self.factory.clients[\"consumer\"]:\n            msg = f\"INPUT:{response}\" + \"\\r\\n\"\n            transport = self.factory.clients[\"consumer\"].transport\n            transport.write(msg.encode(\"utf-8\"))  # type: ignore\n        else:\n            LOGGER.error(\"No consumer connected.\")\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerProtocol.set_factory","title":"<code>set_factory(factory: ServerFactory) -&gt; None</code>","text":"<p>Set the factory.</p> <p>Parameters:</p> Name Type Description Default <code>factory</code> <code>ServerFactory</code> <p>The factory to set.</p> required Source code in <code>waldiez/stream/server.py</code> <pre><code>def set_factory(self, factory: \"ServerFactory\") -&gt; None:\n    \"\"\"Set the factory.\n\n    Parameters\n    ----------\n    factory : ServerFactory\n        The factory to set.\n    \"\"\"\n    self.factory = factory\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerWrapper","title":"<code>ServerWrapper(interface: str, port: int, timeout: Optional[float] = None)</code>","text":"<p>Server Wrapper.</p> <p>Create a new TCP server.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>Interface to listen on. Defaults to '' (all interfaces)</p> required <code>port</code> <code>int</code> <p>Port to listen on.</p> required Source code in <code>waldiez/stream/server.py</code> <pre><code>def __init__(\n    self,\n    interface: str,\n    port: int,\n    timeout: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Create a new TCP server.\n\n    Parameters\n    ----------\n    interface : str\n        Interface to listen on. Defaults to '' (all interfaces)\n    port : int\n        Port to listen on.\n    \"\"\"\n    self.timeout = timeout if timeout is not None else 0.2\n    self.server = TCPServerThread(\n        interface=interface, port=port, timeout=self.timeout\n    )\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerWrapper.port","title":"<code>port: int</code>  <code>property</code>","text":"<p>Get the port.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the server is not running</p>"},{"location":"stream/server/#waldiez.stream.server.ServerWrapper.start","title":"<code>start() -&gt; None</code>","text":"<p>Start the server.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the server is not running</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the server.\n\n    Raises\n    ------\n    RuntimeError\n        If the server is not running\n    \"\"\"\n    if self.server is None:\n        raise RuntimeError(\"server is not running\")\n    self.server.start()\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.ServerWrapper.stop","title":"<code>stop() -&gt; None</code>","text":"<p>Stop the server.</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the server.\"\"\"\n    # pylint: disable=line-too-long\n    self.server.reactor.callFromThread(self.server.reactor.stop)  # type: ignore  # noqa\n    self.server.join()\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServer","title":"<code>TCPServer(port: int, timeout: Optional[float] = None, interface: str = '')</code>","text":"<p>TCP Server.</p> <p>Create a new server.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to listen on.</p> required <code>timeout</code> <code>Optional[float]</code> <p>Timeout for the server.</p> <code>None</code> <code>interface</code> <code>str</code> <p>Interface to listen on. Defaults to '' (all interfaces)</p> <code>''</code> Source code in <code>waldiez/stream/server.py</code> <pre><code>def __init__(\n    self,\n    port: int,\n    timeout: Optional[float] = None,\n    interface: str = \"\",\n) -&gt; None:\n    \"\"\"Create a new server.\n\n    Parameters\n    ----------\n    port : int\n        Port to listen on.\n    timeout : Optional[float]\n        Timeout for the server.\n    interface : str\n        Interface to listen on. Defaults to '' (all interfaces)\n    \"\"\"\n    self._port = port\n    self._timeout = timeout\n    self._interface = interface\n    self._init_wrapper()\n    self._running = False\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServer.is_running","title":"<code>is_running() -&gt; bool</code>","text":"<p>Check if the server is running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the server is running, else False.</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def is_running(self) -&gt; bool:\n    \"\"\"Check if the server is running.\n\n    Returns\n    -------\n    bool\n        True if the server is running, else False.\n    \"\"\"\n    return self._running\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServer.port","title":"<code>port: int</code>  <code>property</code>","text":"<p>Get the port.</p>"},{"location":"stream/server/#waldiez.stream.server.TCPServer.restart","title":"<code>restart() -&gt; None</code>","text":"<p>Restart the server.</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def restart(self) -&gt; None:\n    \"\"\"Restart the server.\"\"\"\n    self.stop()\n    self._init_wrapper()\n    self.start()\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServer.start","title":"<code>start() -&gt; None</code>","text":"<p>Start the server.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the wrapper is not initialized</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the server.\n\n    Raises\n    ------\n    RuntimeError\n        If the wrapper is not initialized\n    \"\"\"\n    if self._running:\n        return\n    if not self._wrapper:\n        raise RuntimeError(\"ServerWrapper not initialized\")\n    self._wrapper.start()\n    self._port = self._wrapper.port\n    self._running = True\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServer.stop","title":"<code>stop() -&gt; None</code>","text":"<p>Stop the server.</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the server.\"\"\"\n    if not self._running:\n        return\n    if not self._wrapper:  # pragma: no cover (just for the linter)\n        return\n    self._wrapper.stop()\n    self._running = False\n    del self._wrapper\n    self._wrapper = None\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServerThread","title":"<code>TCPServerThread(interface: str, port: int, timeout: Optional[float] = None)</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Threaded TCP server.</p> <p>Create a new TCP server.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>Interface to listen on. Defaults to '' (all interfaces)</p> required <code>port</code> <code>int</code> <p>Port to listen on.</p> required <code>timeout</code> <code>Optional[float]</code> <p>Timeout for the server.</p> <code>None</code> Source code in <code>waldiez/stream/server.py</code> <pre><code>def __init__(\n    self,\n    interface: str,\n    port: int,\n    timeout: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Create a new TCP server.\n\n    Parameters\n    ----------\n    interface : str\n        Interface to listen on. Defaults to '' (all interfaces)\n    port : int\n        Port to listen on.\n    timeout : Optional[float]\n        Timeout for the server.\n    \"\"\"\n    super().__init__(\n        name=\"TCPServerThread\",\n        daemon=True,\n        target=self.run,\n    )\n    from twisted.internet.endpoints import TCP4ServerEndpoint\n\n    self.timeout = timeout\n    self.reactor = get_reactor()\n    self._port = port\n    endpoint = TCP4ServerEndpoint(  # type: ignore[no-untyped-call]\n        self.reactor,\n        port,\n        interface=interface,\n    )\n    server_factory = ServerFactory()\n    deferred = endpoint.listen(server_factory)  # type: ignore\n    deferred.addCallback(callback=self.on_start)\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServerThread.on_start","title":"<code>on_start(port: Port) -&gt; None</code>","text":"<p>On connect callback.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>Port</code> <p>The port to connect to.</p> required Source code in <code>waldiez/stream/server.py</code> <pre><code>def on_start(self, port: Port) -&gt; None:\n    \"\"\"On connect callback.\n\n    Parameters\n    ----------\n    port : Port\n        The port to connect to.\n    \"\"\"\n    socket = port.getHost()  # type: ignore[no-untyped-call]\n    LOGGER.debug(\n        \"listening on %s:%s\",\n        socket.host,\n        socket.port,\n    )\n    self._port = socket.port\n    self.factory = port.factory\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.TCPServerThread.port","title":"<code>port: int</code>  <code>property</code>","text":"<p>Get the port.</p>"},{"location":"stream/server/#waldiez.stream.server.TCPServerThread.run","title":"<code>run() -&gt; None</code>","text":"<p>Start the server.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If reactor is not initialized</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Start the server.\n\n    Raises\n    ------\n    RuntimeError\n        If reactor is not initialized\n    \"\"\"\n    if self.reactor is None:  # pragma: no cover (just for the linter)\n        raise RuntimeError(\"reactor is not running\")\n    if not self.reactor.running:\n        self.reactor.run(installSignalHandlers=False)  # type: ignore\n</code></pre>"},{"location":"stream/server/#waldiez.stream.server.get_reactor","title":"<code>get_reactor() -&gt; IReactorCore</code>","text":"<p>Get the reactor from twisted.</p> <p>Returns:</p> Type Description <code>IReactorCore</code> <p>The twisted's reactor</p> Source code in <code>waldiez/stream/server.py</code> <pre><code>def get_reactor() -&gt; IReactorCore:\n    \"\"\"Get the reactor from twisted.\n\n    Returns\n    -------\n    IReactorCore\n        The twisted's reactor\n    \"\"\"\n    # dummy hack to allow restarting the reactor\n    if \"twisted.internet.reactor\" in sys.modules:\n        del sys.modules[\"twisted.internet.reactor\"]\n    import twisted.internet.error\n    from twisted.internet import reactor  # noqa\n    from twisted.internet import default\n\n    try:\n        default.install()\n    # pylint: disable=line-too-long\n    except (\n        twisted.internet.error.ReactorAlreadyInstalledError\n    ):  # pragma: no cover\n        pass\n    # cast it so mypy doesn't complain a lot\n    reactor_cast = cast(IReactorCore, reactor)\n    return reactor_cast\n</code></pre>"}]}